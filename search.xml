<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[you don't know JS 简约版（下）]]></title>
    <url>%2F2018%2F07%2F27%2Fyou%20don't%20know%20JS%20%E7%AE%80%E7%BA%A6%E7%89%88%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入编程程序程序常被称为源码或代码，它是一组特定的指令，用来指示计算机要执行哪些任务 语句程序就是多个语句的集合，它们合起来描述了程序要执行的所有步骤 表达式语句由一个或多个表达式组成。一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。运算符，变量（值与类型），常量。 执行程序解释器或编译器将编写的代码翻译成计算机可以理解的命令 实践Chrome about:blank ，prompt，alert，console 代码块与逻辑语句{}（词法作用域）、条件判断、循环/迭代、函数 编程小结 在值上执行动作需要运算符。 执行各种类型的动作需要值和类型，比如，对数字进行数学运算，用字符串输出。 在程序的执行过程中需要变量来保存数据（也就是状态）。 需要 if 这样的条件判断来作出决策。 需要循环来重复任务，直到不满足某个条件。 需要函数将代码组织为逻辑上可复用的块。 深入 JavaScript 值和类型：弱类型、子类型、装箱、类型转换、对象拷贝 变量：作用域，提升 严格模式的情况 函数：IIFE、闭包（模块） this 标识符 原型 polyfilling 与 transpiling 宿主对象——document、alert(..) ES6js 版本管理 2009 年，ES5 正式发布（然后是 2011 年的 ES5.1） 早期——基于某一组主要特性组合为单位，然后未能按时交付。。。如 ES6：发布日期从 2013 年拖到 2014 年，然后又到 2015 年 ES6 之后——把 JavaScript 未来的版本看成基于单个特性：es2016，es2017 新语法：transpiling——transformation ＋ compiling 新的特性和模式一旦在标准中稳定下来，并且浏览器能够实现它们之后，就能够在开发者的代码中得到应用 利用专门的工具把你的 ES6 代码转化为等价（或近似！）的可以在 ES5 环境下工作的代码 新 API：shim/polyfill ES6 Shim ES6 新语法块作用域 ES5 之前只能函数或 IIFE 创建 { let.. }——隐式 var 都是归属于包含它的整个函数作用域。 let/const 声明归属于块作用域 var 有提升，let/const 不会（TDZ）—— let 声明放在其所在作用域的最前面 const 创建常量，必须要有显式的初始化 块作用域函数 函数默认参数 传参形式 123456// ES5x = x || 11x = x !== undefined ? x : 11x = 0 in arguments ? x : 11// ES6function foo(x = 11) &#123;&#125; 接受默认值表达式——惰性求值 解构——结构化赋值 对象属性赋值模式 target: source解构反转赋值 对象解构形式允许多次列出同一个源属性（持有值类型任意） 数组解构赋值 太多，太少，刚刚好 默认值 12var [a = 3, b = 6, c = 9, d = 12] = foo()var &#123; x = 5, y = 10, z = 15, w = 20 &#125; = bar() 嵌套解构 解构参数 解构默认值＋参数默认值（注意解构默认值和函数参数默认值之间的差别）eg： 123456789function f6(&#123; x = 10 &#125; = &#123;&#125;, &#123; y &#125; = &#123; y: 10 &#125;) &#123; console.log(x, y)&#125;f6() // 10 10f6(undefined, undefined) // 10 10f6(&#123;&#125;, undefined) // 10 10f6(&#123;&#125;, &#123;&#125;) // 10 undefinedf6(undefined, &#123;&#125;) // 10 undefinedf6(&#123; x: 2 &#125;, &#123; y: 3 &#125;) // 2 3 嵌套默认：解构并重组——关键在于属性默认赋值与重新解构赋值结合起来。 1234567891011121314151617// 把defaults合并进config&#123; // (带默认值赋值的)解构 let &#123; options: &#123; remove = defaults.options.remove, enable = defaults.options.enable, instance = defaults.options.instance &#125; = &#123;&#125;, log: &#123; warn = defaults.log.warn, error = defaults.log.error &#125; = &#123;&#125; &#125; = config // 重组 config = &#123; options: &#123; remove, enable, instance &#125;, log: &#123; warn, error &#125; &#125;&#125; 对象字面量扩展 简洁属性{a:a,b:b}=&gt;{a,b} 简洁方法{a:function(){},b:function(){}}=&gt;{a(){},b(){}}(!不适用于递归或者事件绑定 / 解绑定) 计算属性名 设置[[prototype]] Object.setPrototypeOf(..) super.xxx 模板字符量${} 字符串插入表达式——词法作用域内 标签模板字面量123456789function foo(strings, ...values) &#123; cosole.log(string) cosole.log(values)&#125;var desc = 'awesome'foo`Everything is $&#123;desc&#125;!`// 获取并操作原始的变量和字符串，输出如下// [ "Everything is ", "!"]// [ "awesome" ] 箭头函数——简短、绑定 this 词法作用域（优先级最高） 待完善]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[you don't know JS 简约版（中）]]></title>
    <url>%2F2018%2F07%2F26%2Fyou%20don't%20know%20JS%20%E7%AE%80%E7%BA%A6%E7%89%88%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类型和语法类型 概念：类型是值的内部特征，它定义了值的行为，以使其区别于其他值 内置类型：null、undefined、string、number、boolean、object、symbol null 判断：(!null &amp;&amp; typeof null === &quot;object&quot;); // true 其他采用 typeof 判断 Object.prototype.tostring.call()进一步判断对象子类型 undefined 与 undeclared： JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值 js 中将 undefined 与 undeclared 混为一谈，typeof 均返回 undefined typeof 的安全防范机制——用于避免重复定义 值 数组 “稀疏”数组 类数组Array.prototype.slice.call()与Array.from()转换 字符串类数组的结构，本身不可变，常用来与数组相互转换做数据处理：split、join 数字 JavaScript 中的“整数”就是没有小数的十进制数。所以 42.0 即等同于“整数” 42。 JavaScript 中的数字类型是基于 IEEE754 标准来实现的，该标准通常也被称为“浮点数”。 JavaScript 使用的是“双精度”格式（即 64 位二进制） API 指数形式：toExponential() 小数位数：tofixed(..) 有效位数：toPrecision(..) 整数：Number.isInteger(..) 安全整数：Number.isSafeInteger(..) Number.MAX_VALUE 与 Number.MIN_VALUE Number.MAX_SAFE_INTEGER 与 Number.MIN_SAFE_INTEGER 0o（八进制）与 0x（十六进制） 0.1 + 0.2 === 0.3; // false与机器精度123if (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52)&#125; 特殊数值 null 与 undefined null 指空值（empty value），undefined 指没有值（missing value） null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值 void 运算符void 并不改变表达式的结果，只是让表达式不返回值（undefined） NaN——错误的数值Number.isNaN：return n !== n 无穷数 1 / 0; // Infinity -1 / 0; // -Infinity Infinity/Infinity; // NaN 1 / Infinity; 0 -1 / Infinity; -0 保留矢量方向 Object.is(..)判断 NaN 或-012Object.is(a, NaN)Object.is(b, -0) 值与引用 简单值（即标量基本类型值）总是通过值复制的方式来赋值传递，包括 null、 undefined、字符串、数字、布尔和 ES6 中的 symbol。 复合值——对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值 / 传递。 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定 原生函数 内部属性 [[Class]] typeof 返回值为”object”的对象（如数组）都包含一个内部属性[[Class]]，eg：[object Array] 对象的内部 [[Class]] 属性和创建该对象的内建原生构造函数相对应 null 与 undefined1234Object.prototype.toString.call(null)// "[object Null]"Object.prototype.toString.call(undefined)// "[object Undefined]" 封装对象包装 基 本 类 型 值没有.length 和.toString()这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box 或者 wrap）一个封装对象 不提倡用 new 构造封装对象，繁琐容易出错 Date(..) 和 Error(..)没有对应的常量形式来作为它们的替代 使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错 符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名 强制类型转换 概念：将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion 类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时 JSON 不安全的 JSON 值：undefined、function、symbol（ES6+）和包含循环引用 JSON.stringify(..) 在对象中遇到 undefined、 function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变） 对包含循环引用的对象执行 JSON.stringify(..) 会出错 如果传递给 JSON.stringify(..)的对象中定义了 toJSON()方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。 类型装换要先获取简单基本类型值（ToPrimitive 原则）：先是 valueOf()得到简单基本类型值，得不到时转而调用 toString() 12345678// 坑????var i = 2Number.prototype.valueOf = function() &#123; return i++&#125;if (a == 2 &amp;&amp; a == 3) &#123; // ..&#125; 宽松相等（loose equals） == 和严格相等（strict equals） === ——== 允许在相等比较中进行强制类型转换，而===不允许。”；不建议也不提倡用== [] == ![] // true——运行顺序问题，ToPrimitive 原则 以下原则可以让我们有效地避免出错。（我靠，干脆不用！！！还能开开心心撸代码吗？） 如果两边的值中有 true 或者 false，千万不要使用 ==。 如果两边的值中有 []、 “” 或者 0，尽量不要使用 ==。 typeof 判断可以使用 ==。 语法 语句和表达式 语句都有一个返回结果值——代码块的结果值就如同一个隐式的返回，即返回最后一个语句的结果值（函数返回另外） 上下文？介绍{}代码块的一些场景：对象，JSON，代码块，else if 之类的，所以这里是想干嘛？？ 运算符优先级 &amp;&amp; 和 || 运算符的“短路” 自动分号插入（Automatic SemicolonInsertion， ASI） break、 continue、 return 和 yield（ES6）等关键字 错误——并非 词法 错误，而是 语法 错误，发生在编译阶段，无法 try…catch TDZ（Temporal DeadZone，暂时性死区）——指的是由于代码中的变量还没有初始化而不能被引用的情况 函数参数：在 ES6 之前，获得函数所有参数的唯一途径就是 arguments 数组，然后说废就废。。。不要混用 es6 的参数方式和 argument，argument 只和传入的有关。 try..finally finally 中的 return 会覆盖 try 和 catch 中 return 的返回值 finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用 混合环境的 js 宿主环境（浏览器等）创建并提供给 JavaScript 引擎的变量“宿主对象”（包括内建对象和函数） 创建带有 id 属性的 DOM 元素时也会创建同名的全局变量 不要扩展原生原型——无法兼容和考虑未来发展 shim/polyfill——为不符合最新规范的老版本浏览器填补缺失的功能 异步与回调异步程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心 分块的程序 程序代码分块执行，当前指向与未来触发执行任务的便有了同步异步之分 控制台是异步的 事件循环 JavaScript 引擎基于浏览器，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行 事件循环：一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，排队执行程序 伪代码123456789101112131415161718// eventLoop是一个用作队列的数组// （先进，先出）var eventLoop = []var event// “永远”执行while (true) &#123; // 一次tick if (eventLoop.length &gt; 0) &#123; // 拿到队列中的下一个事件 event = eventLoop.shift() // 现在，执行下一个事件 try &#123; event() &#125; catch (err) &#123; reportError(err) &#125; &#125;&#125; 并行线程 线程：最小的执行单元；进程：资源管理配置单元 事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。 js 是单线程的，不跨线程共享数据但是存在竞态条件（异步执行顺序） 并发 此并发是指任务触发上的‘并发’，而非执行上的并发 非交互——不影响彼此——不需要对代码处理 交互——竞态（race）——为后续的执行代码添加门闩（或者说一次性通过钥匙） 协作——互相关联 任务 一个建立在事件循环队列之上，叫作任务队列（job queue） 在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目（一个任务） 事件循环列队就像普通游客，任务队列就是 vip 插队游客 语句顺序代码中语句的顺序和 JavaScript 引擎执行语句的顺序并不一定要一致 回调回调函数是 JavaScript 异步的基本单元 函数、任务的执行依赖于另一个任务的执行，时序上有先后连锁关系 嵌套回调与链式回调—— - 我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷 - 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大,难于理解的代码是坏代码，会导致坏 bug 回调的不确定性导致的信任问题：信任，但要核实 解决回调问题： 分离回调（一个用于成功通知，一个用于出错通知） 1234567function success(data) &#123; console.log(data)&#125;function failure(err) &#123; console.error(err)&#125;ajax('http://some.url', success, failure) “error-first 风格”（“Node 风格”） 1234567891011function response(err, data) &#123; // 出错？ if (err) &#123; console.error(err) &#125; // 否则认为成功 else &#123; console.log(data) &#125;&#125;ajax('http://some.url.1', response) Promise回调表达程序异步和管理并发的两个主要缺陷：缺乏顺序性和可信任性 promise 规范：不把自己程序的 continuation 传给第三方，而是希望第三方给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么 理解 promise 概念：Promise 是一种封装和组合未来值的易于复用的机制 promise 的类型判断 123456789if ( p !== null &amp;&amp; (typeof p === 'object' || typeof p === 'function') &amp;&amp; typeof p.then === 'function') &#123; // 假定这是一个thenable!&#125; else &#123; // 不是thenable&#125; promise 信任问题 调用回调过早——必定异步 调用回调过晚——回调注册独立依次运行不互相影响 回调未调用——超时竞态，错误回调 调用回调次数过少或过多—— Promise 只能被决议一次 未能传递所需的环境和参数——保持其定义所在的作用域的闭包 吞掉可能出现的错误和异常——内部异常捕获机制 Promise.resolve(..)为所有函数的返回值（不管是不是 thenable）都封装一层，保证总会返回一个 Promise 结果 链式流 this 链式流（jquery 方式），操作对象都为当前对象 thenable 链式流（promise），持续展开 thenable 的同时递归地前进 顺序流程控制——符合思维角度，避免出错 理解 resolve，fulfilled 区别：A Promise can either be pending (unresolved), fulfilled (resolved successfully) or rejected (resolved unsuccessfully)123// 函数命名标准规范let p = new Promise(function(resolve, reject) &#123;&#125;)p.then(onFulfilled, onRejected) 错误处理 try..catch 无法处理跨异步操作 Promise 链的一个最佳实践就是最后总以一个 catch(..) 结束 遗留的 catch 里的异常坑 promise 模式 Promise.all([ .. ]) Promise.race([ .. ]) 12345678910111213// 超时竞赛Promise.race([ foo(), // 启动foo() timeoutPromise(3000) // 给它3秒钟]).then( function() &#123; // foo(..)按时完成！ &#125;, function(err) &#123; // 要么foo()被拒绝，要么只是没能够按时完成， // 因此要查看err了解具体原因 &#125;) 变体自定义模式：none([ .. ])、any([ .. ])、first([ .. ])、last([ .. ])、map([..])并发迭代 Promise 的 API new Promise(..) 构造器 Promise.resolve(..) 和 Promise.reject(..)——创建一个状态已确定的 Promise then(fulfilled, rejected ) 和 catch(rejected)（等同于 then(null, rejected )） Promise.all([ .. ]) 和 Promise.race([ .. ])；向 Promise.all([ .. ]) 传入空数组，它会立即完成，但 Promise.race([ .. ]) 会挂住，且永远不会决议 Promise 库处理其他复杂情况 Promise 的局限性 顺序错误处理——内部错误可能无法捕获 返回单一值——数组、对象形式或 promise.all 单决议——一次性用品，多次复用时需要重新 new 一个 惯性——现有回调函数风格整改为 promise 12345678910111213141516171819202122// ajax("http://some.url.1,cb);异步函数为例的整改// polyfill安全的guard检查if (!Promise.wrap) &#123; Promise.wrap = function(fn) &#123; return function() &#123; var args = [].slice.call(arguments) return new Promise(function(resolve, reject) &#123; fn.apply( null, // 把拆分的参数整合，回调函数插入决议 args.concat(function(err, v) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(v) &#125; &#125;) ) &#125;) &#125; &#125;&#125; 性能问题探讨——Promise 非常好，请使用 生成器基于回调的异步：不符合大脑对任务步骤的规划方式；由于控制反转，不是可信任或可组合的 生成器基本概念与写法;yield/next(..)这一对不只是一种控制机制，实际上也是一种双向消息传递机制。 yield 表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined ）。 生成器与迭代器 生成器——闭包方式保存状态与值 iterable 迭代器——需提供 Symbol.iterator 接口 生成器把 while..true 带回了 JavaScript 编程的世界！12345678910111213function* something() &#123; var nextVal // 生成器就是要永远运行 while (true) &#123; // 闭包 if (nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = 3 * nextVal + 6 &#125; yield nextVal &#125;&#125; 异步迭代生成器 我们把异步作为实现细节抽象了出去，使得我们可以以同步顺序的形式追踪流程控制 生成器 yield 暂停的特性意味着我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误 生成器结合 Promise ES7： async 与 await 支持 Promise 的 Generator Runner1234567891011121314151617181920212223242526272829function run(gen) &#123; var args = [].slice.call(arguments, 1), it // 在当前上下文中初始化生成器 it = gen.apply(this, args) // 返回一个promise用于生成器完成 return Promise.resolve().then(function handleNext(value) &#123; // 对下一个yield出的值运行 var next = it.next(value) return (function handleResult(next) &#123; // 生成器运行完毕了吗？ if (next.done) &#123; return next.value &#125; // 否则继续运行 else &#123; return Promise.resolve(next.value).then( // 成功就恢复异步循环，把决议的值发回生成器 handleNext, // 如果value是被拒绝的 promise， // 就把错误传回生成器进行出错处理 function handleErr(err) &#123; return Promise.resolve(it.throw(err)).then(handleResult) &#125; ) &#125; &#125;)(next) &#125;)&#125; 生成器委托——yield *fun yield 委托的主要目的是代码组织，保持生成器分离有助于程序的可读性、可维护性和可调试性 消息委托，异步委托及递归委托 生成器并发 形实转换程序（thunk）12345678910thunkify(foo, 3, 4)function thunkify(fn) &#123; return function() &#123; var args = [].slice.call(arguments) return function(cb) &#123; args.push(cb) return fn.apply(null, args) &#125; &#125;&#125; 程序性能 web worker 概念 JavaScript 是单线程运作，异步并发的 多线程带来的问题：共享的作用域和资源、通信 浏览器启动一个新的线程 1var w1 = new Worker('http://some.url.1/mycoolworker.js') 不会共享任何作用域或资源,基于事件消息机制相互联系 12345// 一对一的关系：message要么来自这个Worker，要么来自主页面w1.addEventListener('message', function(evt) &#123; // evt.data&#125;)w1.postMessage('something cool to say') web worker 工作 环境： 完全独立的线程，不共享 window 网络操作（Ajax、WebSockets）以及设定定时器 navigator 、 location 、 JSON 和 applicationCache 加载脚本 12// 在Worker内部importScripts('foo.js', 'bar.js') 应用场景——把长时间的或资源密集型的任务卸载到不同的线程中，以提高主 UI 线程的响应性。 处理密集型数学计算 大数据集排序 数据处理（压缩、音频分析、图像处理等） 高流量网络通信 数据传递优化——Transferable 对象、结构化克隆算法 SharedWorker123456789101112// 在共享Worker内部addEventListener( "connect", function(evt)&#123; // 这个连接分配的端口 var port = evt.ports[0]; port.addEventListener( "message", function(evt)&#123; // .. port.postMessage( .. ); // .. &#125; ); // 初始化端口连接 port.start();&#125; ); SIMD：CPU 级的并行数学运算映射到 JavaScriptAPI，以获得高性能的数据并行运算，比如在大数据集上的数字处理。 asm.js 模式——描述了 JavaScript 的一个很小的子集，它避免了 JavaScript 难以优化的部分（比如垃圾收集和强制类型转换），并且让 JavaScript 引擎识别并通过激进的优化运行这样的代码。 异步编码模式使我们能够编写更高效的代码，通常能够带来非常大的改进。但是，异步特性只能让你走这么远，因为它本质上还是绑定在一个单事件循环线程上。 性能测试与调优 正确的测试解决方案（基于统计学）——Benchmark.js 检查测试环境——引擎优化带来的未知 jsPerf.com——尽可能多的真实环境下进行实际测试；编写更好更清晰的测试：确保测试的公平，真实环境。 微性能 不要试图和 JavaScript 引擎比谁聪明。对性能优化来说 不要过早优化，权衡大局（考虑可读性等） 尾调用优化——（Tail Call Optimization，TCO） 重用已有的 Fun(..) 的栈帧 return fun（）的函数——递归回调 TCO 允许一个函数在结尾处调用另外一个函数来执行，不需要任何额外资源。这意味着，对递归算法来说，引擎不再需要限制栈深度]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[you don't know JS 简约版（上）]]></title>
    <url>%2F2018%2F07%2F20%2Fyou%20don't%20know%20JS%20%E7%AE%80%E7%BA%A6%E7%89%88%2F</url>
    <content type="text"><![CDATA[据说读书厉害的某高考状元说：把书读薄，把书读厚，然后你就会吃透这本书了。好吧我编不下去了，反正技术书不是网页武侠爽文随便瞄几眼就过去了，要理解吃透相关概念。面对一本书我们都需要好好思考怎么去读它才能最大限度从里面汲取养分，而不是看了好几本想起来脑袋空空。 把书读薄：提取书的框架和要点，乍一看去，就回忆起这部分讲的是什么,形成自己的体系脉络把书读厚：关注书的具体解释，引申意义，细节内容，关联性内容，如同给书做了很多的注释，所以越看越厚 这个系列的书是真滴不错，刷新不少认知也加深很多理解，经典好书当然值得我们好好吸毒。。。细读（这输入法）。但是我觉得它还不够薄，所以再来提炼一波。原书分为上中下三个系列，一口吃不成一个胖子，所以这边也分成三个篇章分别对应。 作用域作用域概念 编译：分词/词法分析,解析/语法分析（Abstract Syntax Tree，AST),代码生成 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询 词法作用域 概念：词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的） eval(..)和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 函数作用域和块作用域 最小特权原则中引申出来，某个模块或对象的 API 设计，接口清晰明了，私有化，模块化 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的置。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式 IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）——避免变量污染全局 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部） 提升var a = 2——JavaScript 引擎第一个是编译阶段的任务，而第二个则是执行阶段的任务；声明（变量和函数）都会被“移动”到各作用域的最顶端，这个过程被称为提升（函数优先） 闭包作用域闭包当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包 12345678910111213141516171819202122232425262728// firstfor (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125;// secondfor (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000) &#125;)()&#125;// thirdfor (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j) &#125;, j * 1000) &#125;)(i)&#125;// forthfor (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125; 模块化实现 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 代码实现 1234567891011121314151617var MyModules = (function Manager() &#123; var modules = &#123;&#125; function define(name, deps, impl) &#123; // deps:模块依赖；这里根据模块名取出对应模块 for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]] &#125; modules[name] = impl.apply(impl, deps) &#125; function get(name) &#123; return modules[name] &#125; return &#123; define: define, get: get &#125;&#125;)() es6 采用文件模块化机制一个文件一个 module，export 导出要暴露的 API，在需要引入的文件里用 import 添加模块并绑定到相应变量上 thisthis 概念 作用：隐式传递上下文对象——精准而优雅 误区：函数内部调用自身与 this 调用自身区别。具名函数可通过函数名访问自身（词法作用域），this 方式则要 call、applay、bind 指向函数。 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域；this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 绑定规则 默认绑定：全局，strict 模式下为 undefined 隐式绑定：对象属性引用链中只有最顶层或者说最后一层会影响调用位置 显式绑定：call(..) 和 apply(..) 12345function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments) &#125;&#125; 为了避免函数作为参数传入调用时丢失上下文，新增硬绑定bind,然后它还能进行柯里化（固定参数） new 绑定：实际上并不存在所谓的“构造函数”， 只有对于函数的“构造调用” 创建（或者说构造） 一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。 绑定优先级new 绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定 =&gt;箭头函数使用词法作用域取代了传统的 this 机制；相当于我们之前的let self = this,最好不要混用两种风格。 有些调用可能在无意中使用默认绑定规则。 如果想“更安全” 地忽略 this 绑定， 你可以使用一个 DMZ 对象， 比如 ø = Object.create(null)， 以保护全局对象 对象内置对象 内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象。在必要时语言会自动把字符串字面量转换成一个 String 对象 String、Number、Boolean、Object、Function、Array、Date、RegExp、Error Object.prototype.tostring.call(obj)=== [object 对象子类型] 对象内容 对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性（引用——指向这些值真正的存储位置） .a 语法通常被称为“属性访问”， [“a”] 语法通常被称为“键访问”；区别在于标识符的命名规范、键访问可接受变量并将变量转为字符串 数组有一套更加结构化的值存储机制，期望的是数值下标，所以谨慎使用可转为数字的属性添加至数组，最好不要以对象形式修改数组属性 对象复制 浅复制 1var newObj = Object.assign(&#123;&#125;, myObject) 深复制 12// JSON 安全的对象var newObj = JSON.parse(JSON.stringify(myObject)) 属性描述符 定义与查看 1234567891011121314Object.defineProperty(obj,a,&#123; value: 1, writable: true, configurable: true, enumerable: true &#125;)，Object.getOwnPropertyDescriptor(obj,a)// &#123;// value: 2,// writable: true,// enumerable: true,// configurable: true// &#125; writable （可写）、enumerable （可枚举）和 configurable （可配置） 严格模式报错，非严格模式静默不生效 设置对象不可变123456// 禁止添加新属性Object.preventExtensions(obj)// 禁止配置或删除已有属性（在上面基础上）Object.seal(obj)// 禁止修改属性值（在上面基础上）Object.freeze(obj) 对象增删查改——[[get]] [[put]] [[get]]：对象中查找是否有名称相同的属性——原型链查找——返回值 undefined [[Put]]：属性是否是访问描述符？存在 setter 就调用 setter：按照属性描述符设置 访问描述符 Getter Setter访问描述符优于属性描述符两种定义方式 123456789101112131415161718192021222324var myObject = &#123; // 给 a 定义一个 getter get a() &#123; return this._a_ &#125;, // 给 a 定义一个 setter set a(val) &#123; this._a_ = val * 2 &#125;&#125;Object.defineProperty( myObject, // 目标对象 'a', // 属性名 &#123; // 描述符 get: function() &#123; return this._a_ * 2 &#125;, set: function(val) &#123; this._a_ = val * 2 &#125; &#125;) 检测属性存在 in 操作符会检查属性是否在对象及其[[Prototype]]原型链中；hasOwnProperty(..) 只会检查属性是否在 myObject 对象中 Object.keys(..) 会返回一个数组，包含所有可枚举属性 propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中 Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举 遍历对象 传统：for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链） ES5：forEach(..) 、 map(..)、every(..) 和 some(..) ES6： for..of （for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。） @iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数1234567891011121314151617181920212223242526// 给任何想遍历的对象定义 @@iteratorObject.defineProperty(myObject, Symbol.iterator, &#123; enumerable: false, // 不可枚举 writable: false, configurable: true, value: function() &#123; var o = this var idx = 0 var ks = Object.keys(o) return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: idx &gt; ks.length &#125; &#125; &#125; &#125;&#125;)// 手动遍历 myObjectvar it = myObject[Symbol.iterator]()it.next()// 用 for..of 遍历 myObjectfor (var v of myObject) &#123; console.log(v)&#125; 混合对象——类类相关的面向对象编程 类理论 类 / 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法 类、继承、实例化、多态概念 类意味着复制。 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 类机制 类是概念，实例化复制相关特性行为后获得副本才是我们的对象 类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例——对象 类继承 面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类 定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为 多态：相同方法可在类继承中重写，多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制到子类中。 原型 对象内置属性[[Prototype]] in、for..in 等查找属性：[[Get]]——对象本身属性——查找 [[Prototype]] 链——Object.prototype 设置属性myObject.foo = &quot;bar&quot;： 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:true），那就会直接在 myObject 中添加一个名为 foo 的新属性， 它是屏蔽属性。 如果在 [[Prototype]]链上层存在 foo，但是它被标记为只读（writable:false）， 那么无法修改已有属性或者在 myObject 上创建屏蔽属性如果运行在严格模式下， 代码会抛出一个错误。 否则， 这条赋值语句会被忽略。 总之， 不会发生屏蔽。 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章）， 那就一定会调用这个 setter。 foo 不会被添加到（或者说屏蔽于） myObject， 也不会重新定义 foo 这个 setter。 理解 js 中的‘类’： JavaScript 中只有对象，但是 js 却一直在模仿类 继承意味着复制操作， JavaScript（默认） 并不会复制对象属性。 相反， JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 构造函数与原型继承 构造函数只是new调用函数，new操作的四个步骤？ 原型继承在于原型链的指向 constructor 是函数原型的自带属性，指向函数，可被修改不靠谱 关联[[prototype]]: 123456789// 直接引用原型，Bar相当于没有用Bar.prototype = Foo.prototype// Foo函数的属性初始化操作可能带来副作用：this.name=nameBar.prototype = new Foo()// 正确做法// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create(Foo.prototype)// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype) 检测原型链关系： 1234// 函数（‘类’）与对象obj instanceof Fun // true// 对象与对象Fun.prototype.isPrototypeOf(Obj) // true .__proto__的实现 12345678910Object.defineProperty(Object.prototype, '__proto__', &#123; get: function() &#123; return Object.getPrototypeOf(this) &#125;, set: function(o) &#123; // ES6 中的 setPrototypeOf(..) Object.setPrototypeOf(this, o) return o &#125;&#125;) class 并没有解决“类”机制的问题，而是隐藏并假装自己是静态类，本质上还是行为委托机制，只是在“类”模仿上走得更远]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再次思考js中的原型]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%86%8D%E6%AC%A1%E6%80%9D%E8%80%83js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[横看成岭侧成峰 远近高低各不同。 前言js 是面向对象设计的语言，而面向对象意味着要先描述对象——规定具体对象的特性与行为。然而在实际中我们可以看到很多对象的特性与行为都可以复用，这意味着这部分代码是可以抽象出来复用的。java 采用了类概念，引申自我们对自然事物的抽象概念，譬如生物课本上的界门纲目科属种。JS，作为一个‘蠢弟弟’，就不这样子干。就不要类的概念，但是为了解决相同的的问题自己搞了一套对象关联对象的东西（所谓继承）——原型与原型链 让我们来new一个对象 为了解决从哪里来到哪里去这个问题，我们可以看对象是怎么定义出来的。看完之后对于这个原型，原型链问题也就迎刃而解了。 字面量方式123456let o = &#123; a: 1, b: 2&#125;// 控制台打印可以看到o._proto_ = Object.prototype 这时候对象原型链指向 Object，于是乎这个新对象有了 Object 的 hasOwnProperty 等方法 构造函数方式我们知道当使用 new 操作符调用函数时，做了四步工作——新建对象，指定新对象的原型链是函数原型，绑定 this，返回新对象 1234567function nothing() &#123; console.log('you got a new object')&#125;nothing.prototype = &#123;&#125;let a = new nothing()// 控制台打印可以看到a._proto_ = nothing.prototype = &#123;&#125; 原型链再一次被使用：链接到对象的继承——原型对象;可能细心的你会发现 a 的 constructor 变成了 Object()，因为这里把函数默认的实例原型对象自带的 constructor 给重置了。实际上 constructor 并不一定表示被 xx 函数构造的意味,它只是函数原型对象的一个默认对象充话费送的，指向当前函数的属性，实际上也没啥卵用。 Object.create()方式相对好理解的对象间委托属性方式 12345let cat = &#123; eat: 'people' &#125;let dog = Object.create(cat)dog._proto_ = catdog.eat = 'people' 我们可以看到 Object.create 方式是直接把新建对象的原型链指向了传入的对象，新对象通过原型链找到了拥有传入对象的属性 class 关键字创建的对象es6 新增的语法糖来方便的构建便于理解的‘继承’关系；毕竟底层还是原型链方式,写法倒是和 java 类继承基本一样，class的本质是构造函数 123456789101112131415161718class Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`I am $&#123;this.name&#125;`) &#125;&#125;// 这里相当于Person.prototype = &#123; constructor(name) &#123; this.name = name &#125;, say() &#123; console.log(`I am $&#123;this.name&#125;`) &#125;&#125;let a = new Person('a') 清晰很多有木有，‘继承’对象的基本属性，方法定义都不再割裂开来，我们可以很方便的定义一个原型对象并初始化它的子对象。 以上，我们了解到一个对象是如何诞生的，也知道，对象的行为、属性来源于另一个所谓的原型对象，以此串联而成的便是原型链，所有的源头的均会回到 js 基本类型 Object.prototype 或 null 就像你不知道的 JS 上一书所阐明的，JS 中对象的描述采用属性委托设计方式而非类继承设计方式。对象间的关联是自由的，也更加强大。再上个图理凑字数也是不错滴：]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端打印实现]]></title>
    <url>%2F2018%2F07%2F16%2Fweb%E5%89%8D%E7%AB%AF%E6%89%93%E5%8D%B0%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[背景需求 基于 web 现代浏览器实现批量打印电子面单（规格固定），各种带条码的单据（规格范围不固定）;如下所示 web 打印技术调研浏览器的菜单打印功能这是最简单的，只需点击页面上的打印菜单，但是也是问题最多的，基本上是不能满足用户需要。比如：不能精确分页，有出现打出半行字的风险；改变纸型后打印出的格式和页面显示的格式相差太大；页眉页脚也需要从菜单中去设置，等等等等。这种方案最大的优势就是不需要做任何代码，点击打印就可以了。 window.print()这实际上，是浏览器打印功能菜单的一种程序调用。与点击打印功能菜单一样，不能精确分页，不能设置纸型，套打的问题更加无从谈起，只不过，可以让用户不用去点菜单，直接点击网页中的一个按钮，或一个链接里面调用罢了。需要指出的是这种方法提供一个打印前和打印后的事件 onbeforeprint、onafterprint。可以在打印前的时候重新编辑一些格式，专门送去打印，打印后又处理回来。 12345678function window.onbeforeprint()&#123;//将一些不需要打印的隐藏&#125;function window.onafterprint()&#123;//放开隐藏的元素&#125; 事实上，很多用户都是采用这种方式打印，但是这种方式最致命的缺点是不能设置打印参数，比如纸型，页边距，选择打印机等等。 导出 excel 导出 pdf 文件的打印将需要打印的数据导出 excel 文件或者导出 pdf 文件，然后打开 excel 文件或者 pdf 文件重新打印，用这种方案能实现精确的打印，套打也能实现，但是需要客户端安装 excel 和 adobe 软件，操作起来也有些麻烦，并且导出的 excel 文件可以重新修改编辑，一般用户都会要求系统提供这种导出的方案，也同时需要直接打印的功能，所以个人觉得这种方案也不能很好的解决打印的问题。 纯 activex 控件这种方案其实就是编写一个 c/s 的打印控件，然后嵌入到页面里面，将要打印的数据装入到控件中，然后打印。这种方案的优点是打印精度高，分页，设置打印参数等等都能实现。但是缺点也是很明显的，嵌入 activex 控件破坏了 web 应用的整体 html 风格，且这样的控件通常都比较大，一般都超过 1m，下载很慢。 applet 方式采用 applet 方式，分页或精确打印，都可以做到完美，但缺点也很明显，表现在：安装 applet 成本巨大。需要下载十几 m 的文件。applet 本身可能并不大，但运行 applet 所需的 jre 一般&gt;10m。用户需要极大的耐心，来进行打印。打印报表时，需要重新向服务器检索数据，效率低。因为 applet 方案，一般采用 html 方式呈现数据，打印时 applet 必须向服务器检索同一张票据的数据，看上去，是打印了当前页的票据，实际上，applet 根本不会用当前 html 页的数据来打印，而是向服务器下载数据到 applet 中来打印。也就是说，打印的话，必须两次请求，一次 html 呈现，一次用来打印。市场上 java 类的报表工具，一般推荐 applet 方式来实现打印。 轻量级的 activex 插件＋ dhtml ＋ javascript ＋后台代码（动态获取数据）轻量级 activex 插件：设置打印参数，比如预定义纸型，设置打印方向，打印边距，指定打印机，不弹出打印对话框直接打印等等。dhtml ＋ javascript 编辑打印数据的格式展现，实现格式的自定义。后台代码，可以是 java，dotnet 等等的，实现动态获取打印数据。这种方案是比较理想的，只需要客户端下载一个很小的打印插件，客户端无需安装任何 c/s 的格式设计 以上来源: 马开东博客几种web表格打印方案的比较 主要有如下主流控件： ScriptX PAZU jatoolsPrinter lodop国内主要是 jatoolsPrinter 和 lodop，对比后 lodop 最合适——技术支持，免费的开放功能丰富 lodop 实现打印打印工具说明Web 打印控件Lodop以插件形式扩展 JavaScript 打印编程接口，使得 web 可以操作控制打印,支持超文本打印或自定义指令打印 打印设计流程 页面检测打印控件安装状态并提示 用户设置打印机、打印格式、字体等 勾选表格数据并点击打印弹框预览 打印状态返回并修改单据打印状态 项目实现基本流程 你可能需要教程资料：C-Lodop 技术手册下载、入门样例及说明 打印控件引入及引导安装控件 JS 文件——LodopFuncs.js对该文件的主函数 getLodop 模块化导出，修改相关文件里安装、调用和升级的程序代码为项目的弹框提示，去除升级检测。 1export function getLodop(oOBJECT, oEMBED) &#123;&#125; 控件在页面内以 object 元素形式被引用。设置元素的 width 和 height 等于 0 来隐藏控件。 采用 js 动态拼接字符串生成 html+css 的超文本并发送到打印插件进行打印 1LODOP.ADD_PRINT_HTM('0mm', '0mm', '100%', '100%', strFormHtml) 设置定时器监听回调捕获打印状态 1234LODOP.On_Return_Remain = trueLODOP.On_Return = function(TaskID, Value) &#123; // 根据TaskID和Value判断打印状态&#125; 模块化封装并设置打印回调 模块化各个打印单据类型项目里面有多个单据，打印的排版，指定打印机，内容等都有所不同，通过定义一个打印主函数，模块化封装各个单据及对应对应参数。我们只需在页面中调用函数并传入单据类型、打印数据及相关参数就可以实现具体单据的打印。 1234567891011121314export printDemo1 = function(data)&#123; printStyle = `样式控制` printHtml = `填入数据的html模板` const params = &#123; type: `Demo1`, printStyle: printStyle, printHtml: printHtml, size: &#123; width: 800, height: 600 &#125; &#125; return params&#125; 主函数流程控制根据传入不同单据类型做处理并执行打印指令 1234567891011import printDemo1 from './printModule/demo1'export function print(type, data) &#123; switch (type) &#123; case 'Demo1': &#123; let params = printDemo1(data) return doPrint(params) &#125; case 'Demo2': ... &#125;&#125; doPrint 函数执行打印返回一个 promise 对象，打印取消、成功或失败后的回调 12345678910function doPrint(params) &#123; return new Promise(function (resolve, reject) &#123; // 打印取消 reject('cancel') // 打印成功 resolve('success') // 打印失败 reject('error') &#125;&#125; 实际调用 1234567891011print(data) .then(res =&gt; &#123; console.info('打印成功') &#125;) .catch(err =&gt; &#123; if (err === 'cancel') &#123; console.warning('打印取消') &#125; else &#123; console.error('打印失败') &#125; &#125;) 电子面单打印——菜鸟打印组件打印工具说明 菜鸟打印组件——模板设计器、打印客户端以及相应的接口和协议(菜鸟物流接入的电子面单都可以打除了顺丰) 模板设计可自定义设置电子面单模板并生成相关代码 打印机客户端用于 web 交互通讯打印相关电子面单 相关接口协议用于前端 web 调用并控制打印设置 打印流程菜鸟打印 demo 文档大致流程如下，相关代码均可写在一个 cainiaoChat.js 文件中并像 lodop 打印那样子模块化并做相关回调处理，打印的实现效果也和上文一致。相关的接口文档比较完善这里就大致讲解一下。 连接打印机打印组件客户机soket接口为13528（https的话，端口是13529）新建websoket连接打印组件并设置相关websoket监听事件 配置打印机,可配置项如下：打印机名称模板上下联logo水平和垂直偏移量页面有无空边打印机纸张宽高 获取电子面单数据并构建打印请求异步请求获取到要打印的电子面单数据=&gt;按照格式要求构造request对象=&gt;把request用websoket发送至菜鸟组件生成电子面单=&gt;打印或预览设置]]></content>
      <tags>
        <tag>web打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端文件上传下载]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前端不时会碰到关于上传图片，下载Excel报表日志之类的业务需求，从原始的form表单提交到new formData()异步上传；从直接window.open(url)到new blob()、new fileReader()读取返回的二进制流文件。都让我们对文件处理更多的选择与操作，本文主要记录前端中关于文件的处理，包括上传下载及相关API。 文件上传文件上传需要先调用读取本地文件API 获取文件方式input方式input[type=&#39;file&#39; multiple]调用，multiple属性可以允许客户上传多个文件。获取该dom节点可以看到有个files属性(FileList对象)，它对应文件列表，是一个类数组，这个列表中的每一个文件，就是一个 file 对象。123456&lt;input type=&apos;file&apos; multiple /&gt;&lt;script&gt; document.querySelector(&apos;input&apos;).onchange = function(e) &#123; console.log(e.target.files); &#125;;&lt;/script&gt; tips:上传同个文件不触发onchange事件——每次上传之后重置input.value（上传文件路径） drag方式dom.ondrop事件获取e.dataTransfer.files（概念同上），dataTransfer指向一个对象，包含了与拖动相关的各种信息12345678910&lt;textarea&gt;&lt;/textarea&gt;&lt;script&gt;const container = document.querySelector('textarea');container.ondragover = function () &#123; return false; &#125;;container.ondrop = function(e) &#123; e.stopPropagation(); e.preventDefault(); console.log(e.dataTransfer.files);&#125;;&lt;/script&gt; file对象通过用户交互获取到需要上传的文件，它的属性如下： name：文件名 size：文件大小，单位为字节，可以根据文件大小来进行限制 type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，可以由此来限制只允许上传图片 lastModified：文件的上次修改时间，格式为时间戳。 lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例。 FileReader 对象有时候我们需要读取文件的一些内容，例如预览图片；而FileReader对象就是用来把文件读入内存，并且读取文件中的数据接受 File 对象或 Blob 对象作为参数。常规操作——按照需求方式读取文件并处理文件12345reader.onload = function (ev) &#123; console.log(ev.target.result) console.log(reader.result)&#125;reader.readAs**方式**(file); 原始form表单提交方式1234&lt;form action="/saveFile" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="fileName" /&gt; &lt;button type="submit"&gt;上传&lt;/button&gt;&lt;/form&gt; 貌似也没啥问题，可是会刷新网页！这就尴尬了，很多情况下我们不想这样子，所以ajax提交来了。 ajax构建FormData提交先来看看FormData——模拟form表单将数据编译成键值对，以便用XMLHttpRequest来发送数据123let FormData = new FormData();FormData.append(name, file);ajax(FormData)... 文件下载传统下载原理是直接访问网络资源地址，触发浏览器下载行为 window.open(url)或iframe方式。iframe已被弃用，新建窗口打开资源文件方式会有一闪而过的现象，不大友好。 a 标签的 download 属性 异步下载原理是获取到文件后重新构造文件URL，访问下载。在这里需要了解一下blob blob对象上文中，File 对象便是是继承自 Blob 对象，Blob 对象代表了一段二进制数据，它有两个属性：size 属性表示字节长度，type 属性表示 MIME 类型。1let blob = new Blob([&apos;hello blob&apos;], &#123;type:&quot;text/plain&quot;&#125;); Blob 构造函数中的第一个参数是一个数组，可以存放 ArrayBuffer对象、ArrayBufferView 对象、Blob对象和字符串此外还可以通过blob对象slice或canvas.toBlob()方式构造。 ajax文件下载 首先要理清responseType, 即返回类型，根据不同返回类型ajax去不同地方取返回值并做不同处理，如下：xhr.response：ArrayBuffer、Blob、Document，jsonxhr.responseText：DOMString（等同于默认设置responseType=’’）这里我们根据自身需求设置responseType 下载的文件处理 12345678910111213141516// 对返回的文件构造做兼容处理res = 'response' in xhr ? xhr.response : xhr.responseTextlet file = new Blob([res])// 创建a链接模拟点击下载downloadFile(file, name, type = 'xlsx') &#123; let url = window.URL.createObjectURL(file) let link = document.createElement('a') link.style.display = 'none' link.href = url // 设置下载文件名 link.setAttribute('download', `$&#123;name&#125;.$&#123;type&#125;`) document.body.appendChild(link) link.click() document.body.removeChild(link)&#125;]]></content>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目内嵌Cordova]]></title>
    <url>%2F2018%2F07%2F10%2FVue%E9%A1%B9%E7%9B%AE%E5%86%85%E5%B5%8CCordova%2F</url>
    <content type="text"><![CDATA[现下前端可谓是花开满地，在各个地方异彩纷呈，问题也接踵而至（。。。怎么这么多成语）。多端统一是愿景，cordova便是其中之一，不巧项目有用到，做一个小 demo 总结吧。 小项目介绍本项目用 vue cli(3.0.0) + vue(2.5.16) + cordova(8.x)构建一个项目原型——Vue 项目内嵌 cordova 安卓平台。按流程走，有坑的地方已经用我的肉体填平了,相关源码地址请参阅vue-cordova。 认识 cordovaApache Cordova 是一个开源的移动开发框架。允许你用标准的 web 技术-HTML5,CSS3 和 JavaScript 做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的 API 绑定去访问每个设备的功能 跨平台开发；调用底层硬件设备 cordova 安装使用 官网入门 demo 搭建安卓平台环境 添加插件 设置热更新 调试:android studio\google_inspect 安卓开发环境搭建 准备工作：下载安装android studio、JDK、Android SDK JDK——JDK 的全称是 Java SE Development Kit，也就是 Java 开发工具箱。SE 表示标准版。JDK 是 Java 的核心，包含了 Java 的运行环境（Java Runtime Environment），一堆 Java 工具和给开发者开发应用程序时调用的 Java 类库，JDK 包含的基本工具主要有： - javac：Java 编译器，将源代码转成字节码。 - jar：打包工具，将相关的类文件打包成一个文件。 - javadoc：文档生成器，从源码注释中提取文档。 - java：运行编译后的 java 程序。配置 JDK 的系统变量环境——JAVA_HOME android studio——集成的 Android 开发工具用于开发和调试（自带 gradle 构建安卓项目） Android SDK——Android SDK 提供了开发 Android 应用程序所需的 API 库和构建、测试和调试 Android 应用程序所需的开发工具，环境变量配置：Android SDK 安装目录下的 platform-tools 和 tools——ANDROID_HOME tips： cmd 命令——echo %path%查看修改成功与否（可能需要重新打开 cmd 窗口） jdk10（最新版本有坑别去踩），jdk8 就行了——影响安卓 sdk 安装（检测不到 jdk 环境） 安装安卓 sdk 可以选择 exe 或文件下载。注意要配置 tools 和 platform-tools，下载安卓不同版本的开发包（Android target） 安卓项目构建需要 gradle，可能还有些依赖，需要下载 android studio 帮忙配置（设置离线 gradle，下载代理加速，这些 Cordova 做不了） 不要 cnpm 安装 cordova，不然只能安装 6.0.0 的否则 create 不了项目（报错文件缺失） 初始化 Vue 项目依次运行如下命令： 12npm install -g @vue/clivue create vue-cordova 相关文档参照vue cli 文档——得到如下图（这时候可能大概需要在项目下面创建一个 vue.config.js 用来配置项目打包运行） 在 vue 项目下创建 cordova 安装 cordova 命令 1npm install -g cordova 创建 cordova 项目 1cordova create cordovaDemo Apache.myCompany.cordovaDemo cordovaDemo 项目配置修改 在 vue 根项目下.ignore 文件中添加如下代码，之后在 cordovaDemo 目录下运行 cordova prepare 会自动安装平台和插件 12345# cordovacordovaDemo/platformscordovaDemo/pluginscordovaDemo/wwwcordovaDemo/res index.html 插入 cordova.js 12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="cordova.js"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt; vue 项目 main.js 中配置在设备准备后才加载 vue 1234567891011121314151617181920let app = &#123; // Application Constructor initialize: function() &#123; document.addEventListener( 'deviceready', this.onDeviceReady.bind(this), false ) &#125;, // deviceready Event Handler // // Bind any cordova events here. Common events are: // 'pause', 'resume', etc. onDeviceReady: function() &#123; new Vue(&#123; render: h =&gt; h(App) &#125;).$mount('#app') &#125;&#125;app.initialize() 修改 Vue 项目打包生成路径，打包引用为相对路径 123456module.exports = &#123; // 设置打包引用为相对路径 baseUrl: './', // 输出构建的文件的地方 outputDir: 'cordovaDemo/www'&#125; 小试牛刀——调用手机拍照 hybrid app 到目前为止基本的 Vue 集成 cordova 项目就完成了，可以使用 cordova 进行开发 Hybrid App；在这里我们添加一个安卓平台并调用拍照功能获取我们拍到的照片 添加安卓平台 1cordova platform add android --save 添加相机插件 1cordova plugin add cordova-plugin-camera --save 我们可以在 cordova 的项目下的config.xml配置文件最后面看·到如下代码，大家可以类比这个config.xml相当于我们平常项目里的 package.json 管理依赖，运行cordoava prepare即可自动安装项目所需插件与平台 12&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 调用相机的代码——此处应该查看api 文档 123456789101112&lt;template&gt; &lt;div class="app"&gt; &lt;h1&gt;Apache Cordova&lt;/h1&gt; &lt;div id="deviceready" class="blink"&gt; &lt;p class="event listening"&gt;Connecting to Device&lt;/p&gt; &lt;p class="event received"&gt;Device is Ready&lt;/p&gt; &lt;/div&gt; &lt;button @click="handleCamera()"&gt;打开相机&lt;/button&gt; &lt;button @click="showNavigator()"&gt;查看navigator.camera&lt;/button&gt; &lt;img id="myImage" src="" alt="获取相片"&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415onSuccess(imageData) &#123; var image = document.getElementById('myImage'); image.src = "data:image/jpeg;base64," + imageData;&#125;,onFail(message) &#123; alert('Failed because: ' + message);&#125;,handleCamera() &#123; navigator.camera.getPicture(this.onSuccess, this.onFail, &#123; quality: 25, destinationType: window.Camera.DestinationType.DATA_URL &#125;);&#125; 构建项目 vue 项目打包——生成 cordova 目录下的 www 文件 1npm run build cordova 项目打包 www 文件(注意切换目录) 1cordova build android 生成 apk 文件，我们安装到手机上——嗯!可以用的 貌似到这里就完了，可是。。。 每次都要发布 app 不累吗？而且用户也不喜欢啊！所以热更新来了 插件 Cordova Hot Code Push Plugin,基本原理是为 www 目录下的每个文件加多一个 hash 值追踪(chcp.manifest 文件)，有更改的文件便会被在 apk 启动检查到然后被更新 添加热更新插件,开发环境部署测试，热更新部署命令 123cordova plugin add cordova-hot-code-push-plugin --savecordova plugin add cordova-hot-code-push-local-dev-addon --savenpm install cordova-hot-code-push-cli --save 执行热更新发布并开启热更新环境 123cordova-hcp server// 或者只是执行热更新发布**这时候需要部署到线上环境**cordova-hcp build 这时候会生成cordovaDemo下的.chcpenv、www目录下的chcp.json、chcp.manifest文件 根据线上部署或生产调试设置热更新检查的–URL–(项目的地址，确保apk能访问得到配置文件)1234567&lt;chcp&gt; &lt;config-file url="URL/chcp.json" /&gt;&lt;/chcp&gt;&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;plugin name="cordova-hot-code-push-plugin" spec="^1.5.3" /&gt;&lt;plugin name="cordova-hot-code-push-local-dev-addon" spec="^0.4.2" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 最后cordova打包生成apk并安装（这里我指定URL为本机的局域网IP和对应的端口） 测试更新效果 修改Apache Cordova 为HotCodePush Cordova Vue项目重新打包 执行cordova-hcp server apk退出重新打开过几秒就可以看到，修改成功 一路走来好像顺风顺水的，其实并不是啊——调试！！！ 安卓真机调试我们可以用chrome://inspect/#devices或者android studio，当然后者更强大不过有时候对前端小伙伴来说 Chrome 的就够了，而且也亲切。 chrome://inspect/#devices 方式 直接在谷歌 url 复制粘贴该地址回车便可以进入该模式，开启Discover USB devices发现设备 打开手机的usb 调试模式，需要先打开开发者模式 连接手机打开网页，点击设备下出现的网页inspect进入调试 android studio 支持虚拟设备和真机调试 指定 android sdk 需要 android sdk 下的 ADB——用于连接调试设备 gradle 构建，apk 安装到手机，手机 apk 面的日志会打印到 logcat 中 tips inspect 时报错 http1.1 404 Not found——第一次使用 google inspect 需要翻墙下载一些东西 vue 项目 build 到 cordova 源项目；cordova 项目 build 到安卓项目，Android studio run 进行调试（或者直接 cordova 打包） cordova 项目的 index 中引入 Content-Security-Policy——不允许在 html 中直接添加事件，可以将它注释掉 部分 google 的 inspect 不兼容所有的手机网页所以测试是否连接成功首选手机 google 调试，怀疑和内核有关或者部分 app 内部做了限制]]></content>
      <tags>
        <tag>Hybrid APP 架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画]]></title>
    <url>%2F2018%2F05%2F04%2FCSS%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[区分 animation（动画）、transition（过渡）、 transform（变形）、translate(平移)；理解各个 css 属性对应的常用取值与应用 transform——对元素 2D 或 3D 转换1transform: none|transform-functions; transform-functions——对应函数有如下： translate：平移 scale：缩放 rotate(angle)：旋转 skew(angle)：倾斜 备注： 以上函数基于平面，其他对应的有-X、-Y、-3d，分别对应 X 轴、Y 轴、3D 转换 transform-functions 接受多个函数，eg：1transform: translate(10px,20px) scale(.5,.5); transition——定义过渡状态的过程1transition&#123; transition-property transition-duration transition-timing-function transition-delay&#125; 对应属性值概念如下： transition-delay transition-duration transition-property transition-timing-function——对应值 linear：匀速 ease-in：加速 ease-out：减速（ease-in-out） cubic-bezier 函数：自定义速度模式 触发方式： 伪类触发：:hover : focus :checked :active js 触发：toggleClass 注意： IE10+ 不是所有的CSS属性都支持transition transition的优点在于简单易用，但是它有几个很大的局限。 transition需要事件触发，所以没法在网页加载时自动发生。 transition是一次性的，不能重复发生，除非一再触发。 transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 Animation——定义帧动画(指定动画一个周期持续的时间，以及动画效果)1animation: 1s 1s actionName linear 3 forwards normal; 对应属性值 1234567animation-delay: 1s;animation-duration: 1s;animation-name: actionName;animation-timing-function: linear;animation-iteration-count: 3;animation-fill-mode: forwards;animation-direction: normal; 简写 1animation: 1s 1s rainbow linear 3 forwards normal; 动画事件对应处理 1234567891011@keyframes name &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next建站踩坑记]]></title>
    <url>%2F2018%2F04%2F11%2Fhexo-next%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HEXO: A fast, simple &amp; powerful blog frameworkNEXT: A high quality elegant Hexo theme. It is crafted from scratch, with love hexo搭建网站丢上官网文档，按照官网的步骤走这里要了解一下各个目录文件的作用： public——最终生成的网站文件 scaffolds——生成文件模板，可定制个性化 source——顾名思义，我们对项目的内容编辑都在这里进行 博文——分为草稿、发布 静态资源存放地 其他页文件 thems——主题目录，对应得博客主题就存放在这里，当然也可以放多个随意切换 next主题引入与配置在引入next主题之前我是用yilia主题的，奈何发现各种小bug，虽然可以自定义修改，但是安装了npm包后，hexo编译主题文件不是一堆内存溢出就是打开文件太多错误提示。这个问题怀疑是hexo编译主题的时候把node_module一起……想想都可怕；移除了node_module之后就不会了，然后移进来又会了，oh shit！再去看着yilia一堆open的issue果断转投next。 还是丢官网文档，感觉官网文档很不错，不过坑还是有的，或者有一些雾里看花压根就没怎么和你讲。 侧边栏的各种关于、标签页都需要在配置新增之后显示，而后用hexo新增对应的页面，博客url管理是日期或者对应文件目录形式，可以看看public文件下面就知道了 查找功能 注意版本 本地查找一般没啥毛病——原理是基于本地搜索引擎全局查找web站点页面 algolia插件——远程备份需要查找匹配列表的关键信息（json形式），查找时去请求匹配到对应的数据，以便达到快速定位的查找项，以下是具体步骤： 创建注册algolia账号 安装hexo algolia用于生成推送文档关键词npm install --save hexo-algolia 配置站点配置文件algolia: applicationID: &apos;applicationID&apos; indexName: &apos;indexName&apos; chunkSize: 500 配置主题配置文件algolia: applicationID: apiKey: indexName: 推送更新搜索json至algoliahexo algolia 打开搜索功能配置项algolia_search: enable: true]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git备忘录]]></title>
    <url>%2F2018%2F04%2F10%2Fgit%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Git 理解与常用命令汇总 git 工作流作为一个版本控制管理系统工具，如何做到的？分布式管理仓库，分为当前工作区和.git 文件保存的文件版本管理区；一个版本统一 hash 值作为版本 ID；文件在工作区修改之后都需要提交更改到本地 git 的版本管理中才能推送更改到远程仓库中。具体的操作看图片 任何对象都是在工作区中诞生和被修改; 任何修改都是从进入 index 区才开始被版本控制; 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹; 与协作者分享本地的修改，可以把它们 push 到远程仓库来共享。 本地版本管理 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD 就会跟着改变，Git 允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id 版本标签: 1234567命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；命令git tag可以查看所有标签。 远程仓库同步 关联远程仓库：git remote add origin git@server-name:path/repo-name.git、git clone git@github.com:Devil0/repository.git 同步操作：push、pull、fetch 分支管理brach用于开发协同管理，涉及展示分支，切换分支，创建分支，删除分支这四种操作]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新认识JS]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[概述高中读化学时一直觉得知识点好零碎，徘徊门外分数也上不去；后来高一舍友告诉我要形成自己的体系，闭上眼睛都能想象得出化学的课本章节，可以从元素周期表或是有机无机开始为基点打造自己的学习体系脉络；说来也神奇，有了这个想法后学习真的轻松不少，打怪升级分数也上去了。废话有点多，谁让 js 是一门不需要学习就能直接先用的语言呢？导致不少人压根就迷迷糊糊的或者雾里看花似懂非懂；那个什么鬼前端知识图片就是坑，算了，入正题。。。 何为程序作为一个电子信息科学与技术专业，学硬件又学软件什么的，大学算是有过了一遍从基础电信号——数电——汇编——C 语言的大致历史，个人理解的电子世界是这样的：01 电信号构成基石——排列组合逻辑运算构成数字芯片实现一定功能（输入输出及存储），排列组合构成功能指令——为编程方便简化指令成为汇编语言（assembling）——进一步简化为各个分支c、c++、c#、java、.net……(高级语言) 定位——轻量级的脚本语言脚本语言的主要特征是：程序代码即是脚本程序，亦是最终可执行文件。脚本语言可分为独立型和嵌入型，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如 C，C++，VB，Java 等）被嵌入使用 JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 阮一峰什么是 JavaScript 语言 JS 在 web 方面应用，目前主要在宿主环境有 NODE 和浏览器，客户端与服务端。 js 的核心语法 类对象编程语法 基本的语法构造 标准库 宿主环境提供的 API 基础语法 基于规则的一门语言，类似我们学的自然语言，从最简单的拼音字母到词乃至句子表达的意思——对于程序来说则意味着命令 变量 标识符（保留字） 注释 区块 作用域 var const 与 let 逻辑语句 条件语句——if、switch、? : 循环语句——for、do until、while（break跳出当前循环、continue用于终止循环） 数据类型 js作为一门动态类型语言，其实是没有所谓类型可言，对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值 空类型 null undefined 原始类型/值类型——变量存值新开内存 string——base64（字符编码二进制转换用于传输）btoa()、atob() number——64位浮点数、精度、范围、parseInt（string,formats）、parseFloat boolean——自动转为false的情况：undefined、null、NaN、0、’’ 复合类型/引用类型——变量存对象地址新开内存，属性值另外存 object——子类有 array、function、object 对象深、浅拷贝null undefined区别值类型确定：typeof、instanceof、Object.prototype.toStringNaN（Not a Number）——任何运算都是自身，属于Number；Infinity——无穷大/小，非0数值除以0；两者运算求导，不可导为NaN typeof12typeof a === 'undefined' // 用于检测变量、函数是否定义!a &amp;&amp; typeof a === 'object' // 检测null，可检测出的为除null基本数据类型+function 对象概念： 数据集或功能集——面向对象编程123抽象性：抽取我们所需要的数据信息等封装性继承性 js没有类概念，何为类？——具有某些共同特性对象的集合。不理解？还记得生物课上的界门纲目科属种吗，或者交通工具-汽车-本田-具体到某个型号。嗯，只可意会不可言传。 类有大类小类，就像一个包着一个的圈圈，小类拥有大类的特性——引申出类继承也有部分圈的交叉，这时候涉及混合，先不讨论 我们认知里面的对象，不就是可以通过这些来定义吗？所以有了对象通过类的实例化 js是面向对象概念语言，直接就规定了具体对象的特性与行为，这时候对象与对象直接就完全隔离，那如何复用一些共同的特性与行为呢？于是乎有了prototype（原型），顾名思义便是对象的来源——另一个原型对象；这样子很明显会有个源头——Object，一层套一层所以和类有个鬼区别？原型对象有个constructor（构造函数）属性原型对象原型链函数对象构造函数数组 继承对象的特性，需要区分类数组（arguments）类数组转为数组或使用数组方法： 12let arr = Array.prototype.slice.call(arrayLike)Array.prototype.forEach.call(arrayLike, fn)]]></content>
      <categories>
        <category>JS体系</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
