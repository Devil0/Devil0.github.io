<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再次思考js中的原型]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%86%8D%E6%AC%A1%E6%80%9D%E8%80%83js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[横看成岭侧成峰 远近高低各不同。 前言js 是面向对象设计的语言，而面向对象意味着要先描述对象——规定具体对象的特性与行为。然而在实际中我们可以看到很多对象的特性与行为都可以复用，这意味着这部分代码是可以抽象出来复用的。java 采用了类概念，引申自我们对自然事物的抽象概念，譬如生物课本上的界门纲目科属种。JS，作为一个‘蠢弟弟’，就不这样子干。就不要类的概念，但是为了解决相同的的问题自己搞了一套对象关联对象的东西（所谓继承）——原型与原型链 让我们来new一个对象 为了解决从哪里来到哪里去这个问题，我们可以看对象是怎么定义出来的。看完之后对于这个原型，原型链问题也就迎刃而解了。 字面量方式123456let o = &#123; a: 1, b: 2&#125;// 控制台打印可以看到o._proto_ = Object.prototype 这时候对象原型链指向 Object，于是乎这个新对象有了 Object 的 hasOwnProperty 等方法 构造函数方式我们知道当使用 new 操作符调用函数时，做了四步工作——新建对象，指定新对象的原型链是函数原型，绑定 this，返回新对象 1234567function nothing() &#123; console.log('you got a new object')&#125;nothing.prototype = &#123;&#125;let a = new nothing()// 控制台打印可以看到a._proto_ = nothing.prototype = &#123;&#125; 原型链再一次被使用：链接到对象的继承——原型对象;可能细心的你会发现 a 的 constructor 变成了 Object()，因为这里把函数默认的实例原型对象自带的 constructor 给重置了。实际上 constructor 并不一定表示被 xx 函数构造的意味,它只是函数原型对象的一个默认对象充话费送的，指向当前函数的属性，实际上也没啥卵用。 Object.create()方式相对好理解的对象间委托属性方式 12345let cat = &#123; eat: 'people' &#125;let dog = Object.create(cat)dog._proto_ = catdog.eat = 'people' 我们可以看到 Object.create 方式是直接把新建对象的原型链指向了传入的对象，新对象通过原型链找到了拥有传入对象的属性 class 关键字创建的对象es6 新增的语法糖来方便的构建便于理解的‘继承’关系；毕竟底层还是原型链方式,写法倒是和 java 类继承基本一样，class的本质是构造函数 123456789101112131415161718class Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`I am $&#123;this.name&#125;`) &#125;&#125;// 这里相当于Person.prototype = &#123; constructor(name) &#123; this.name = name &#125;, say() &#123; console.log(`I am $&#123;this.name&#125;`) &#125;&#125;let a = new Person('a') 清晰很多有木有，‘继承’对象的基本属性，方法定义都不再割裂开来，我们可以很方便的定义一个原型对象并初始化它的子对象。 以上，我们了解到一个对象是如何诞生的，也知道，对象的行为、属性来源于另一个所谓的原型对象，以此串联而成的便是原型链，所有的源头的均会回到 js 基本类型 Object.prototype 或 null 就像你不知道的 JS 上一书所阐明的，JS 中对象的描述采用属性委托设计方式而非类继承设计方式。对象间的关联是自由的，也更加强大。再上个图理凑字数也是不错滴：]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端打印实现]]></title>
    <url>%2F2018%2F07%2F16%2Fweb%E5%89%8D%E7%AB%AF%E6%89%93%E5%8D%B0%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[背景需求 基于 web 现代浏览器实现批量打印电子面单（规格固定），各种带条码的单据（规格范围不固定）;如下所示 web 打印技术调研浏览器的菜单打印功能这是最简单的，只需点击页面上的打印菜单，但是也是问题最多的，基本上是不能满足用户需要。比如：不能精确分页，有出现打出半行字的风险；改变纸型后打印出的格式和页面显示的格式相差太大；页眉页脚也需要从菜单中去设置，等等等等。这种方案最大的优势就是不需要做任何代码，点击打印就可以了。 window.print()这实际上，是浏览器打印功能菜单的一种程序调用。与点击打印功能菜单一样，不能精确分页，不能设置纸型，套打的问题更加无从谈起，只不过，可以让用户不用去点菜单，直接点击网页中的一个按钮，或一个链接里面调用罢了。需要指出的是这种方法提供一个打印前和打印后的事件 onbeforeprint、onafterprint。可以在打印前的时候重新编辑一些格式，专门送去打印，打印后又处理回来。 12345678function window.onbeforeprint()&#123;//将一些不需要打印的隐藏&#125;function window.onafterprint()&#123;//放开隐藏的元素&#125; 事实上，很多用户都是采用这种方式打印，但是这种方式最致命的缺点是不能设置打印参数，比如纸型，页边距，选择打印机等等。 导出 excel 导出 pdf 文件的打印将需要打印的数据导出 excel 文件或者导出 pdf 文件，然后打开 excel 文件或者 pdf 文件重新打印，用这种方案能实现精确的打印，套打也能实现，但是需要客户端安装 excel 和 adobe 软件，操作起来也有些麻烦，并且导出的 excel 文件可以重新修改编辑，一般用户都会要求系统提供这种导出的方案，也同时需要直接打印的功能，所以个人觉得这种方案也不能很好的解决打印的问题。 纯 activex 控件这种方案其实就是编写一个 c/s 的打印控件，然后嵌入到页面里面，将要打印的数据装入到控件中，然后打印。这种方案的优点是打印精度高，分页，设置打印参数等等都能实现。但是缺点也是很明显的，嵌入 activex 控件破坏了 web 应用的整体 html 风格，且这样的控件通常都比较大，一般都超过 1m，下载很慢。 applet 方式采用 applet 方式，分页或精确打印，都可以做到完美，但缺点也很明显，表现在：安装 applet 成本巨大。需要下载十几 m 的文件。applet 本身可能并不大，但运行 applet 所需的 jre 一般&gt;10m。用户需要极大的耐心，来进行打印。打印报表时，需要重新向服务器检索数据，效率低。因为 applet 方案，一般采用 html 方式呈现数据，打印时 applet 必须向服务器检索同一张票据的数据，看上去，是打印了当前页的票据，实际上，applet 根本不会用当前 html 页的数据来打印，而是向服务器下载数据到 applet 中来打印。也就是说，打印的话，必须两次请求，一次 html 呈现，一次用来打印。市场上 java 类的报表工具，一般推荐 applet 方式来实现打印。 轻量级的 activex 插件＋ dhtml ＋ javascript ＋后台代码（动态获取数据）轻量级 activex 插件：设置打印参数，比如预定义纸型，设置打印方向，打印边距，指定打印机，不弹出打印对话框直接打印等等。dhtml ＋ javascript 编辑打印数据的格式展现，实现格式的自定义。后台代码，可以是 java，dotnet 等等的，实现动态获取打印数据。这种方案是比较理想的，只需要客户端下载一个很小的打印插件，客户端无需安装任何 c/s 的格式设计 以上来源: 马开东博客几种web表格打印方案的比较 主要有如下主流控件： ScriptX PAZU jatoolsPrinter lodop国内主要是 jatoolsPrinter 和 lodop，对比后 lodop 最合适——技术支持，免费的开放功能丰富 lodop 实现打印打印工具说明Web 打印控件Lodop以插件形式扩展 JavaScript 打印编程接口，使得 web 可以操作控制打印,支持超文本打印或自定义指令打印 打印设计流程 页面检测打印控件安装状态并提示 用户设置打印机、打印格式、字体等 勾选表格数据并点击打印弹框预览 打印状态返回并修改单据打印状态 项目实现基本流程 你可能需要教程资料：C-Lodop 技术手册下载、入门样例及说明 打印控件引入及引导安装控件 JS 文件——LodopFuncs.js对该文件的主函数 getLodop 模块化导出，修改相关文件里安装、调用和升级的程序代码为项目的弹框提示，去除升级检测。 1export function getLodop(oOBJECT, oEMBED) &#123;&#125; 控件在页面内以 object 元素形式被引用。设置元素的 width 和 height 等于 0 来隐藏控件。 采用 js 动态拼接字符串生成 html+css 的超文本并发送到打印插件进行打印 1LODOP.ADD_PRINT_HTM('0mm', '0mm', '100%', '100%', strFormHtml) 设置定时器监听回调捕获打印状态 1234LODOP.On_Return_Remain = trueLODOP.On_Return = function(TaskID, Value) &#123; // 根据TaskID和Value判断打印状态&#125; 模块化封装并设置打印回调 模块化各个打印单据类型项目里面有多个单据，打印的排版，指定打印机，内容等都有所不同，通过定义一个打印主函数，模块化封装各个单据及对应对应参数。我们只需在页面中调用函数并传入单据类型、打印数据及相关参数就可以实现具体单据的打印。 1234567891011121314export printDemo1 = function(data)&#123; printStyle = `样式控制` printHtml = `填入数据的html模板` const params = &#123; type: `Demo1`, printStyle: printStyle, printHtml: printHtml, size: &#123; width: 800, height: 600 &#125; &#125; return params&#125; 主函数流程控制根据传入不同单据类型做处理并执行打印指令 1234567891011import printDemo1 from './printModule/demo1'export function print(type, data) &#123; switch (type) &#123; case 'Demo1': &#123; let params = printDemo1(data) return doPrint(params) &#125; case 'Demo2': ... &#125;&#125; doPrint 函数执行打印返回一个 promise 对象，打印取消、成功或失败后的回调 12345678910function doPrint(params) &#123; return new Promise(function (resolve, reject) &#123; // 打印取消 reject('cancel') // 打印成功 resolve('success') // 打印失败 reject('error') &#125;&#125; 实际调用 1234567891011print(data) .then(res =&gt; &#123; console.info('打印成功') &#125;) .catch(err =&gt; &#123; if (err === 'cancel') &#123; console.warning('打印取消') &#125; else &#123; console.error('打印失败') &#125; &#125;) 电子面单打印——菜鸟打印组件打印工具说明 菜鸟打印组件——模板设计器、打印客户端以及相应的接口和协议(菜鸟物流接入的电子面单都可以打除了顺丰) 模板设计可自定义设置电子面单模板并生成相关代码 打印机客户端用于 web 交互通讯打印相关电子面单 相关接口协议用于前端 web 调用并控制打印设置 打印流程菜鸟打印 demo 文档大致流程如下，相关代码均可写在一个 cainiaoChat.js 文件中并像 lodop 打印那样子模块化并做相关回调处理，打印的实现效果也和上文一致。相关的接口文档比较完善这里就大致讲解一下。 连接打印机打印组件客户机soket接口为13528（https的话，端口是13529）新建websoket连接打印组件并设置相关websoket监听事件 配置打印机,可配置项如下：打印机名称模板上下联logo水平和垂直偏移量页面有无空边打印机纸张宽高 获取电子面单数据并构建打印请求异步请求获取到要打印的电子面单数据=&gt;按照格式要求构造request对象=&gt;把request用websoket发送至菜鸟组件生成电子面单=&gt;打印或预览设置]]></content>
      <tags>
        <tag>web打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端文件上传下载]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前端不时会碰到关于上传图片，下载Excel报表日志之类的业务需求，从原始的form表单提交到new formData()异步上传；从直接window.open(url)到new blob()、new fileReader()读取返回的二进制流文件。都让我们对文件处理更多的选择与操作，本文主要记录前端中关于文件的处理，包括上传下载及相关API。 文件上传文件上传需要先调用读取本地文件API 获取文件方式input方式input[type=&#39;file&#39; multiple]调用，multiple属性可以允许客户上传多个文件。获取该dom节点可以看到有个files属性(FileList对象)，它对应文件列表，是一个类数组，这个列表中的每一个文件，就是一个 file 对象。123456&lt;input type=&apos;file&apos; multiple /&gt;&lt;script&gt; document.querySelector(&apos;input&apos;).onchange = function(e) &#123; console.log(e.target.files); &#125;;&lt;/script&gt; tips:上传同个文件不触发onchange事件——每次上传之后重置input.value（上传文件路径） drag方式dom.ondrop事件获取e.dataTransfer.files（概念同上），dataTransfer指向一个对象，包含了与拖动相关的各种信息12345678910&lt;textarea&gt;&lt;/textarea&gt;&lt;script&gt;const container = document.querySelector('textarea');container.ondragover = function () &#123; return false; &#125;;container.ondrop = function(e) &#123; e.stopPropagation(); e.preventDefault(); console.log(e.dataTransfer.files);&#125;;&lt;/script&gt; file对象通过用户交互获取到需要上传的文件，它的属性如下： name：文件名 size：文件大小，单位为字节，可以根据文件大小来进行限制 type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，可以由此来限制只允许上传图片 lastModified：文件的上次修改时间，格式为时间戳。 lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例。 FileReader 对象有时候我们需要读取文件的一些内容，例如预览图片；而FileReader对象就是用来把文件读入内存，并且读取文件中的数据接受 File 对象或 Blob 对象作为参数。常规操作——按照需求方式读取文件并处理文件12345reader.onload = function (ev) &#123; console.log(ev.target.result) console.log(reader.result)&#125;reader.readAs**方式**(file); 原始form表单提交方式1234&lt;form action="/saveFile" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="fileName" /&gt; &lt;button type="submit"&gt;上传&lt;/button&gt;&lt;/form&gt; 貌似也没啥问题，可是会刷新网页！这就尴尬了，很多情况下我们不想这样子，所以ajax提交来了。 ajax构建FormData提交先来看看FormData——模拟form表单将数据编译成键值对，以便用XMLHttpRequest来发送数据123let FormData = new FormData();FormData.append(name, file);ajax(FormData)... 文件下载传统下载原理是直接访问网络资源地址，触发浏览器下载行为 window.open(url)或iframe方式。iframe已被弃用，新建窗口打开资源文件方式会有一闪而过的现象，不大友好。 a 标签的 download 属性 异步下载原理是获取到文件后重新构造文件URL，访问下载。在这里需要了解一下blob blob对象上文中，File 对象便是是继承自 Blob 对象，Blob 对象代表了一段二进制数据，它有两个属性：size 属性表示字节长度，type 属性表示 MIME 类型。1let blob = new Blob([&apos;hello blob&apos;], &#123;type:&quot;text/plain&quot;&#125;); Blob 构造函数中的第一个参数是一个数组，可以存放 ArrayBuffer对象、ArrayBufferView 对象、Blob对象和字符串此外还可以通过blob对象slice或canvas.toBlob()方式构造。 ajax文件下载 首先要理清responseType, 即返回类型，根据不同返回类型ajax去不同地方取返回值并做不同处理，如下：xhr.response：ArrayBuffer、Blob、Document，jsonxhr.responseText：DOMString（等同于默认设置responseType=’’）这里我们根据自身需求设置responseType 下载的文件处理 12345678910111213141516// 对返回的文件构造做兼容处理res = 'response' in xhr ? xhr.response : xhr.responseTextlet file = new Blob([res])// 创建a链接模拟点击下载downloadFile(file, name, type = 'xlsx') &#123; let url = window.URL.createObjectURL(file) let link = document.createElement('a') link.style.display = 'none' link.href = url // 设置下载文件名 link.setAttribute('download', `$&#123;name&#125;.$&#123;type&#125;`) document.body.appendChild(link) link.click() document.body.removeChild(link)&#125;]]></content>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目内嵌Cordova]]></title>
    <url>%2F2018%2F07%2F10%2FVue%E9%A1%B9%E7%9B%AE%E5%86%85%E5%B5%8CCordova%2F</url>
    <content type="text"><![CDATA[现下前端可谓是花开满地，在各个地方异彩纷呈，问题也接踵而至（。。。怎么这么多成语）。多端统一是愿景，cordova便是其中之一，不巧项目有用到，做一个小 demo 总结吧。 小项目介绍本项目用 vue cli(3.0.0) + vue(2.5.16) + cordova(8.x)构建一个项目原型——Vue 项目内嵌 cordova 安卓平台。按流程走，有坑的地方已经用我的肉体填平了,相关源码地址请参阅vue-cordova。 认识 cordovaApache Cordova 是一个开源的移动开发框架。允许你用标准的 web 技术-HTML5,CSS3 和 JavaScript 做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的 API 绑定去访问每个设备的功能 跨平台开发；调用底层硬件设备 cordova 安装使用 官网入门 demo 搭建安卓平台环境 添加插件 设置热更新 调试:android studio\google_inspect 安卓开发环境搭建 准备工作：下载安装android studio、JDK、Android SDK JDK——JDK 的全称是 Java SE Development Kit，也就是 Java 开发工具箱。SE 表示标准版。JDK 是 Java 的核心，包含了 Java 的运行环境（Java Runtime Environment），一堆 Java 工具和给开发者开发应用程序时调用的 Java 类库，JDK 包含的基本工具主要有： - javac：Java 编译器，将源代码转成字节码。 - jar：打包工具，将相关的类文件打包成一个文件。 - javadoc：文档生成器，从源码注释中提取文档。 - java：运行编译后的 java 程序。配置 JDK 的系统变量环境——JAVA_HOME android studio——集成的 Android 开发工具用于开发和调试（自带 gradle 构建安卓项目） Android SDK——Android SDK 提供了开发 Android 应用程序所需的 API 库和构建、测试和调试 Android 应用程序所需的开发工具，环境变量配置：Android SDK 安装目录下的 platform-tools 和 tools——ANDROID_HOME tips： cmd 命令——echo %path%查看修改成功与否（可能需要重新打开 cmd 窗口） jdk10（最新版本有坑别去踩），jdk8 就行了——影响安卓 sdk 安装（检测不到 jdk 环境） 安装安卓 sdk 可以选择 exe 或文件下载。注意要配置 tools 和 platform-tools，下载安卓不同版本的开发包（Android target） 安卓项目构建需要 gradle，可能还有些依赖，需要下载 android studio 帮忙配置（设置离线 gradle，下载代理加速，这些 Cordova 做不了） 不要 cnpm 安装 cordova，不然只能安装 6.0.0 的否则 create 不了项目（报错文件缺失） 初始化 Vue 项目依次运行如下命令： 12npm install -g @vue/clivue create vue-cordova 相关文档参照vue cli 文档——得到如下图（这时候可能大概需要在项目下面创建一个 vue.config.js 用来配置项目打包运行） 在 vue 项目下创建 cordova 安装 cordova 命令 1npm install -g cordova 创建 cordova 项目 1cordova create cordovaDemo Apache.myCompany.cordovaDemo cordovaDemo 项目配置修改 在 vue 根项目下.ignore 文件中添加如下代码，之后在 cordovaDemo 目录下运行 cordova prepare 会自动安装平台和插件 12345# cordovacordovaDemo/platformscordovaDemo/pluginscordovaDemo/wwwcordovaDemo/res index.html 插入 cordova.js 12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="cordova.js"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt; vue 项目 main.js 中配置在设备准备后才加载 vue 1234567891011121314151617181920let app = &#123; // Application Constructor initialize: function() &#123; document.addEventListener( 'deviceready', this.onDeviceReady.bind(this), false ) &#125;, // deviceready Event Handler // // Bind any cordova events here. Common events are: // 'pause', 'resume', etc. onDeviceReady: function() &#123; new Vue(&#123; render: h =&gt; h(App) &#125;).$mount('#app') &#125;&#125;app.initialize() 修改 Vue 项目打包生成路径，打包引用为相对路径 123456module.exports = &#123; // 设置打包引用为相对路径 baseUrl: './', // 输出构建的文件的地方 outputDir: 'cordovaDemo/www'&#125; 小试牛刀——调用手机拍照 hybrid app 到目前为止基本的 Vue 集成 cordova 项目就完成了，可以使用 cordova 进行开发 Hybrid App；在这里我们添加一个安卓平台并调用拍照功能获取我们拍到的照片 添加安卓平台 1cordova platform add android --save 添加相机插件 1cordova plugin add cordova-plugin-camera --save 我们可以在 cordova 的项目下的config.xml配置文件最后面看·到如下代码，大家可以类比这个config.xml相当于我们平常项目里的 package.json 管理依赖，运行cordoava prepare即可自动安装项目所需插件与平台 12&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 调用相机的代码——此处应该查看api 文档 123456789101112&lt;template&gt; &lt;div class="app"&gt; &lt;h1&gt;Apache Cordova&lt;/h1&gt; &lt;div id="deviceready" class="blink"&gt; &lt;p class="event listening"&gt;Connecting to Device&lt;/p&gt; &lt;p class="event received"&gt;Device is Ready&lt;/p&gt; &lt;/div&gt; &lt;button @click="handleCamera()"&gt;打开相机&lt;/button&gt; &lt;button @click="showNavigator()"&gt;查看navigator.camera&lt;/button&gt; &lt;img id="myImage" src="" alt="获取相片"&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415onSuccess(imageData) &#123; var image = document.getElementById('myImage'); image.src = "data:image/jpeg;base64," + imageData;&#125;,onFail(message) &#123; alert('Failed because: ' + message);&#125;,handleCamera() &#123; navigator.camera.getPicture(this.onSuccess, this.onFail, &#123; quality: 25, destinationType: window.Camera.DestinationType.DATA_URL &#125;);&#125; 构建项目 vue 项目打包——生成 cordova 目录下的 www 文件 1npm run build cordova 项目打包 www 文件(注意切换目录) 1cordova build android 生成 apk 文件，我们安装到手机上——嗯!可以用的 貌似到这里就完了，可是。。。 每次都要发布 app 不累吗？而且用户也不喜欢啊！所以热更新来了 插件 Cordova Hot Code Push Plugin,基本原理是为 www 目录下的每个文件加多一个 hash 值追踪(chcp.manifest 文件)，有更改的文件便会被在 apk 启动检查到然后被更新 添加热更新插件,开发环境部署测试，热更新部署命令 123cordova plugin add cordova-hot-code-push-plugin --savecordova plugin add cordova-hot-code-push-local-dev-addon --savenpm install cordova-hot-code-push-cli --save 执行热更新发布并开启热更新环境 123cordova-hcp server// 或者只是执行热更新发布**这时候需要部署到线上环境**cordova-hcp build 这时候会生成cordovaDemo下的.chcpenv、www目录下的chcp.json、chcp.manifest文件 根据线上部署或生产调试设置热更新检查的–URL–(项目的地址，确保apk能访问得到配置文件)1234567&lt;chcp&gt; &lt;config-file url="URL/chcp.json" /&gt;&lt;/chcp&gt;&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;plugin name="cordova-hot-code-push-plugin" spec="^1.5.3" /&gt;&lt;plugin name="cordova-hot-code-push-local-dev-addon" spec="^0.4.2" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 最后cordova打包生成apk并安装（这里我指定URL为本机的局域网IP和对应的端口） 测试更新效果 修改Apache Cordova 为HotCodePush Cordova Vue项目重新打包 执行cordova-hcp server apk退出重新打开过几秒就可以看到，修改成功 一路走来好像顺风顺水的，其实并不是啊——调试！！！ 安卓真机调试我们可以用chrome://inspect/#devices或者android studio，当然后者更强大不过有时候对前端小伙伴来说 Chrome 的就够了，而且也亲切。 chrome://inspect/#devices 方式 直接在谷歌 url 复制粘贴该地址回车便可以进入该模式，开启Discover USB devices发现设备 打开手机的usb 调试模式，需要先打开开发者模式 连接手机打开网页，点击设备下出现的网页inspect进入调试 android studio 支持虚拟设备和真机调试 指定 android sdk 需要 android sdk 下的 ADB——用于连接调试设备 gradle 构建，apk 安装到手机，手机 apk 面的日志会打印到 logcat 中 tips inspect 时报错 http1.1 404 Not found——第一次使用 google inspect 需要翻墙下载一些东西 vue 项目 build 到 cordova 源项目；cordova 项目 build 到安卓项目，Android studio run 进行调试（或者直接 cordova 打包） cordova 项目的 index 中引入 Content-Security-Policy——不允许在 html 中直接添加事件，可以将它注释掉 部分 google 的 inspect 不兼容所有的手机网页所以测试是否连接成功首选手机 google 调试，怀疑和内核有关或者部分 app 内部做了限制]]></content>
      <tags>
        <tag>Hybrid APP 架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画]]></title>
    <url>%2F2018%2F05%2F04%2FCSS%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[区分 animation（动画）、transition（过渡）、 transform（变形）、translate(平移)；理解各个 css 属性对应的常用取值与应用 transform——对元素 2D 或 3D 转换1transform: none|transform-functions; transform-functions——对应函数有如下： translate：平移 scale：缩放 rotate(angle)：旋转 skew(angle)：倾斜 备注： 以上函数基于平面，其他对应的有-X、-Y、-3d，分别对应 X 轴、Y 轴、3D 转换 transform-functions 接受多个函数，eg：1transform: translate(10px,20px) scale(.5,.5); transition——定义过渡状态的过程1transition&#123; transition-property transition-duration transition-timing-function transition-delay&#125; 对应属性值概念如下： transition-delay transition-duration transition-property transition-timing-function——对应值 linear：匀速 ease-in：加速 ease-out：减速（ease-in-out） cubic-bezier 函数：自定义速度模式 触发方式： 伪类触发：:hover : focus :checked :active js 触发：toggleClass 注意： IE10+ 不是所有的CSS属性都支持transition transition的优点在于简单易用，但是它有几个很大的局限。 transition需要事件触发，所以没法在网页加载时自动发生。 transition是一次性的，不能重复发生，除非一再触发。 transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 Animation——定义帧动画(指定动画一个周期持续的时间，以及动画效果)1animation: 1s 1s actionName linear 3 forwards normal; 对应属性值 1234567animation-delay: 1s;animation-duration: 1s;animation-name: actionName;animation-timing-function: linear;animation-iteration-count: 3;animation-fill-mode: forwards;animation-direction: normal; 简写 1animation: 1s 1s rainbow linear 3 forwards normal; 动画事件对应处理 1234567891011@keyframes name &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next建站踩坑记]]></title>
    <url>%2F2018%2F04%2F11%2Fhexo-next%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HEXO: A fast, simple &amp; powerful blog frameworkNEXT: A high quality elegant Hexo theme. It is crafted from scratch, with love hexo搭建网站丢上官网文档，按照官网的步骤走这里要了解一下各个目录文件的作用： public——最终生成的网站文件 scaffolds——生成文件模板，可定制个性化 source——顾名思义，我们对项目的内容编辑都在这里进行 博文——分为草稿、发布 静态资源存放地 其他页文件 thems——主题目录，对应得博客主题就存放在这里，当然也可以放多个随意切换 next主题引入与配置在引入next主题之前我是用yalia主题的，奈何发现各种小bug，虽然可以自定义修改，但是安装了npm包后，hexo编译主题文件不是一堆内存溢出就是打开文件太多错误提示。这个问题怀疑是hexo编译主题的时候把node_module一起……想想都可怕；移除了node_module之后就不会了，然后移进来又会了，oh shit！再去看着yalia一堆open的issue果断转投next。 还是丢官网文档，感觉官网文档很不错，不过坑还是有的，或者有一些雾里看花压根就没怎么和你讲。 侧边栏的各种关于、标签页都需要在配置新增之后显示，而后用hexo新增对应的页面，博客url管理是日期或者对应文件目录形式，可以看看public文件下面就知道了 查找功能 注意版本 本地查找一般没啥毛病——原理是基于本地搜索引擎全局查找web站点页面 algolia插件——远程备份需要查找匹配列表的关键信息（json形式），查找时去请求匹配到对应的数据，以便达到快速定位的查找项，以下是具体步骤： 创建注册algolia账号 安装hexo algolia用于生成推送文档关键词npm install --save hexo-algolia 配置站点配置文件algolia: applicationID: &apos;applicationID&apos; indexName: &apos;indexName&apos; chunkSize: 500 配置主题配置文件algolia: applicationID: apiKey: indexName: 推送更新搜索json至algoliahexo algolia 打开搜索功能配置项algolia_search: enable: true]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git备忘录]]></title>
    <url>%2F2018%2F04%2F10%2Fgit%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Git 理解与常用命令汇总 git 工作流作为一个版本控制管理系统工具，如何做到的？分布式管理仓库，分为当前工作区和.git 文件保存的文件版本管理区；一个版本统一 hash 值作为版本 ID；文件在工作区修改之后都需要提交更改到本地 git 的版本管理中才能推送更改到远程仓库中。具体的操作看图片 任何对象都是在工作区中诞生和被修改; 任何修改都是从进入 index 区才开始被版本控制; 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹; 与协作者分享本地的修改，可以把它们 push 到远程仓库来共享。 本地版本管理 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD 就会跟着改变，Git 允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id 版本标签: 1234567命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；命令git tag可以查看所有标签。 远程仓库同步 关联远程仓库：git remote add origin git@server-name:path/repo-name.git、git clone git@github.com:Devil0/repository.git 同步操作：push、pull、fetch 分支管理brach用于开发协同管理，涉及展示分支，切换分支，创建分支，删除分支这四种操作]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新认识JS]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[概述高中读化学时一直觉得知识点好零碎，徘徊门外分数也上不去；后来高一舍友告诉我要形成自己的体系，闭上眼睛都能想象得出化学的课本章节，可以从元素周期表或是有机无机开始为基点打造自己的学习体系脉络；说来也神奇，有了这个想法后学习真的轻松不少，打怪升级分数也上去了。废话有点多，谁让 js 是一门不需要学习就能直接先用的语言呢？导致不少人压根就迷迷糊糊的或者雾里看花似懂非懂；那个什么鬼前端知识图片就是坑，算了，入正题。。。 何为程序作为一个电子信息科学与技术专业，学硬件又学软件什么的，大学算是有过了一遍从基础电信号——数电——汇编——C 语言的大致历史，个人理解的电子世界是这样的：01 电信号构成基石——排列组合逻辑运算构成数字芯片实现一定功能（输入输出及存储），排列组合构成功能指令——为编程方便简化指令成为汇编语言（assembling）——进一步简化为各个分支c、c++、c#、java、.net……(高级语言) 定位——轻量级的脚本语言脚本语言的主要特征是：程序代码即是脚本程序，亦是最终可执行文件。脚本语言可分为独立型和嵌入型，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如 C，C++，VB，Java 等）被嵌入使用 JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 阮一峰什么是 JavaScript 语言 JS 在 web 方面应用，目前主要在宿主环境有 NODE 和浏览器，客户端与服务端。 js 的核心语法 类对象编程语法 基本的语法构造 标准库 宿主环境提供的 API 基础语法 基于规则的一门语言，类似我们学的自然语言，从最简单的拼音字母到词乃至句子表达的意思——对于程序来说则意味着命令 变量 标识符（保留字） 注释 区块 作用域 var const 与 let 逻辑语句 条件语句——if、switch、? : 循环语句——for、do until、while（break跳出当前循环、continue用于终止循环） 数据类型 js作为一门动态类型语言，其实是没有所谓类型可言，对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值 空类型 null undefined 原始类型/值类型——变量存值新开内存 string——base64（字符编码二进制转换用于传输）btoa()、atob() number——64位浮点数、精度、范围、parseInt（string,formats）、parseFloat boolean——自动转为false的情况：undefined、null、NaN、0、’’ 复合类型/引用类型——变量存对象地址新开内存，属性值另外存 object——子类有 array、function、object 对象深、浅拷贝null undefined区别值类型确定：typeof、instanceof、Object.prototype.toStringNaN（Not a Number）——任何运算都是自身，属于Number；Infinity——无穷大/小，非0数值除以0；两者运算求导，不可导为NaN typeof12typeof a === 'undefined' // 用于检测变量、函数是否定义!a &amp;&amp; typeof a === 'object' // 检测null，可检测出的为除null基本数据类型+function 对象概念： 数据集或功能集——面向对象编程123抽象性：抽取我们所需要的数据信息等封装性继承性 js没有类概念，何为类？——具有某些共同特性对象的集合。不理解？还记得生物课上的界门纲目科属种吗，或者交通工具-汽车-本田-具体到某个型号。嗯，只可意会不可言传。 类有大类小类，就像一个包着一个的圈圈，小类拥有大类的特性——引申出类继承也有部分圈的交叉，这时候涉及混合，先不讨论 我们认知里面的对象，不就是可以通过这些来定义吗？所以有了对象通过类的实例化 js是面向对象概念语言，直接就规定了具体对象的特性与行为，这时候对象与对象直接就完全隔离，那如何复用一些共同的特性与行为呢？于是乎有了prototype（原型），顾名思义便是对象的来源——另一个原型对象；这样子很明显会有个源头——Object，一层套一层所以和类有个鬼区别？原型对象有个constructor（构造函数）属性原型对象原型链函数对象构造函数数组 继承对象的特性，需要区分类数组（arguments）类数组转为数组或使用数组方法： 12let arr = Array.prototype.slice.call(arrayLike)Array.prototype.forEach.call(arrayLike, fn)]]></content>
      <categories>
        <category>JS体系</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
