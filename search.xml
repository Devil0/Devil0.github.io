<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端文件上传下载]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前端不时会碰到关于上传图片，下载Excel报表日志之类的业务需求，从原始的form表单提交到new formData()异步上传；从直接window.open(url)到new blob()、new fileReader()读取返回的二进制流文件。都让我们对文件处理更多的选择与操作，本文主要记录前端中关于文件的处理，包括上传下载及相关API。 文件上传文件上传需要先调用读取本地文件API 获取文件方式input方式input[type=&#39;file&#39; multiple]调用，multiple属性可以允许客户上传多个文件。获取该dom节点可以看到有个files属性(FileList对象)，它对应文件列表，是一个类数组，这个列表中的每一个文件，就是一个 file 对象。123456&lt;input type=&apos;file&apos; multiple /&gt;&lt;script&gt; document.querySelector(&apos;input&apos;).onchange = function(e) &#123; console.log(e.target.files); &#125;;&lt;/script&gt; tips:上传同个文件不触发onchange事件——每次上传之后重置input.value（上传文件路径） drag方式dom.ondrop事件获取e.dataTransfer.files（概念同上），dataTransfer指向一个对象，包含了与拖动相关的各种信息12345678910&lt;textarea&gt;&lt;/textarea&gt;&lt;script&gt;const container = document.querySelector('textarea');container.ondragover = function () &#123; return false; &#125;;container.ondrop = function(e) &#123; e.stopPropagation(); e.preventDefault(); console.log(e.dataTransfer.files);&#125;;&lt;/script&gt; file对象通过用户交互获取到需要上传的文件，它的属性如下： name：文件名 size：文件大小，单位为字节，可以根据文件大小来进行限制 type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，可以由此来限制只允许上传图片 lastModified：文件的上次修改时间，格式为时间戳。 lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例。 FileReader 对象有时候我们需要读取文件的一些内容，例如预览图片；而FileReader对象就是用来把文件读入内存，并且读取文件中的数据接受 File 对象或 Blob 对象作为参数。常规操作——按照需求方式读取文件并处理文件12345reader.onload = function (ev) &#123; console.log(ev.target.result) console.log(reader.result)&#125;reader.readAs**方式**(file); 原始form表单提交方式1234&lt;form action="/saveFile" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="fileName" /&gt; &lt;button type="submit"&gt;上传&lt;/button&gt;&lt;/form&gt; 貌似也没啥问题，可是会刷新网页！这就尴尬了，很多情况下我们不想这样子，所以ajax提交来了。 ajax构建FormData提交先来看看FormData——模拟form表单将数据编译成键值对，以便用XMLHttpRequest来发送数据123let FormData = new FormData();FormData.append(name, file);ajax(FormData)... 文件下载传统下载原理是直接访问网络资源地址，触发浏览器下载行为 window.open(url)或iframe方式。iframe已被弃用，新建窗口打开资源文件方式会有一闪而过的现象，不大友好。 a 标签的 download 属性 异步下载原理是获取到文件后重新构造文件URL，访问下载。在这里需要了解一下blob blob对象上文中，File 对象便是是继承自 Blob 对象，Blob 对象代表了一段二进制数据，它有两个属性：size 属性表示字节长度，type 属性表示 MIME 类型。1let blob = new Blob([&apos;hello blob&apos;], &#123;type:&quot;text/plain&quot;&#125;); Blob 构造函数中的第一个参数是一个数组，可以存放 ArrayBuffer对象、ArrayBufferView 对象、Blob对象和字符串此外还可以通过blob对象slice或canvas.toBlob()方式构造。 ajax文件下载 首先要理清responseType, 即返回类型，根据不同返回类型ajax去不同地方取返回值并做不同处理，如下：xhr.response：ArrayBuffer、Blob、Document，jsonxhr.responseText：DOMString（等同于默认设置responseType=’’）这里我们根据自身需求设置responseType 下载的文件处理 12345678910111213141516// 对返回的文件构造做兼容处理res = 'response' in xhr ? xhr.response : xhr.responseTextlet file = new Blob([res])// 创建a链接模拟点击下载downloadFile(file, name, type = 'xlsx') &#123; let url = window.URL.createObjectURL(file) let link = document.createElement('a') link.style.display = 'none' link.href = url // 设置下载文件名 link.setAttribute('download', `$&#123;name&#125;.$&#123;type&#125;`) document.body.appendChild(link) link.click() document.body.removeChild(link)&#125;]]></content>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目内嵌Cordova]]></title>
    <url>%2F2018%2F07%2F10%2FVue%E9%A1%B9%E7%9B%AE%E5%86%85%E5%B5%8CCordova%2F</url>
    <content type="text"><![CDATA[现下前端可谓是花开满地，在各个地方异彩纷呈，问题也接踵而至（。。。怎么这么多成语）。多端统一是愿景，cordova便是其中之一，不巧项目有用到，做一个小 demo 总结吧。 小项目介绍本项目用 vue cli(3.0.0) + vue(2.5.16) + cordova(8.x)构建一个项目原型——Vue 项目内嵌 cordova 安卓平台。按流程走，有坑的地方已经用我的肉体填平了,相关源码地址请参阅vue-cordova。 认识 cordovaApache Cordova 是一个开源的移动开发框架。允许你用标准的 web 技术-HTML5,CSS3 和 JavaScript 做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的 API 绑定去访问每个设备的功能 跨平台开发；调用底层硬件设备 cordova 安装使用 官网入门 demo 搭建安卓平台环境 添加插件 设置热更新 调试:android studio\google_inspect 安卓开发环境搭建 准备工作：下载安装android studio、JDK、Android SDK JDK——JDK 的全称是 Java SE Development Kit，也就是 Java 开发工具箱。SE 表示标准版。JDK 是 Java 的核心，包含了 Java 的运行环境（Java Runtime Environment），一堆 Java 工具和给开发者开发应用程序时调用的 Java 类库，JDK 包含的基本工具主要有： - javac：Java 编译器，将源代码转成字节码。 - jar：打包工具，将相关的类文件打包成一个文件。 - javadoc：文档生成器，从源码注释中提取文档。 - java：运行编译后的 java 程序。配置 JDK 的系统变量环境——JAVA_HOME android studio——集成的 Android 开发工具用于开发和调试（自带 gradle 构建安卓项目） Android SDK——Android SDK 提供了开发 Android 应用程序所需的 API 库和构建、测试和调试 Android 应用程序所需的开发工具，环境变量配置：Android SDK 安装目录下的 platform-tools 和 tools——ANDROID_HOME tips： cmd 命令——echo %path%查看修改成功与否（可能需要重新打开 cmd 窗口） jdk10（最新版本有坑别去踩），jdk8 就行了——影响安卓 sdk 安装（检测不到 jdk 环境） 安装安卓 sdk 可以选择 exe 或文件下载。注意要配置 tools 和 platform-tools，下载安卓不同版本的开发包（Android target） 安卓项目构建需要 gradle，可能还有些依赖，需要下载 android studio 帮忙配置（设置离线 gradle，下载代理加速，这些 Cordova 做不了） 不要 cnpm 安装 cordova，不然只能安装 6.0.0 的否则 create 不了项目（报错文件缺失） 初始化 Vue 项目依次运行如下命令： 12npm install -g @vue/clivue create vue-cordova 相关文档参照vue cli 文档——得到如下图（这时候可能大概需要在项目下面创建一个 vue.config.js 用来配置项目打包运行） 在 vue 项目下创建 cordova 安装 cordova 命令 1npm install -g cordova 创建 cordova 项目 1cordova create cordovaDemo Apache.myCompany.cordovaDemo cordovaDemo 项目配置修改 在 vue 根项目下.ignore 文件中添加如下代码，之后在 cordovaDemo 目录下运行 cordova prepare 会自动安装平台和插件 12345# cordovacordovaDemo/platformscordovaDemo/pluginscordovaDemo/wwwcordovaDemo/res index.html 插入 cordova.js 12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="cordova.js"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt; vue 项目 main.js 中配置在设备准备后才加载 vue 1234567891011121314151617181920let app = &#123; // Application Constructor initialize: function() &#123; document.addEventListener( 'deviceready', this.onDeviceReady.bind(this), false ) &#125;, // deviceready Event Handler // // Bind any cordova events here. Common events are: // 'pause', 'resume', etc. onDeviceReady: function() &#123; new Vue(&#123; render: h =&gt; h(App) &#125;).$mount('#app') &#125;&#125;app.initialize() 修改 Vue 项目打包生成路径，打包引用为相对路径 123456module.exports = &#123; // 设置打包引用为相对路径 baseUrl: './', // 输出构建的文件的地方 outputDir: 'cordovaDemo/www'&#125; 小试牛刀——调用手机拍照 hybrid app 到目前为止基本的 Vue 集成 cordova 项目就完成了，可以使用 cordova 进行开发 Hybrid App；在这里我们添加一个安卓平台并调用拍照功能获取我们拍到的照片 添加安卓平台 1cordova platform add android --save 添加相机插件 1cordova plugin add cordova-plugin-camera --save 我们可以在 cordova 的项目下的config.xml配置文件最后面看·到如下代码，大家可以类比这个config.xml相当于我们平常项目里的 package.json 管理依赖，运行cordoava prepare即可自动安装项目所需插件与平台 12&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 调用相机的代码——此处应该查看api 文档 123456789101112&lt;template&gt; &lt;div class="app"&gt; &lt;h1&gt;Apache Cordova&lt;/h1&gt; &lt;div id="deviceready" class="blink"&gt; &lt;p class="event listening"&gt;Connecting to Device&lt;/p&gt; &lt;p class="event received"&gt;Device is Ready&lt;/p&gt; &lt;/div&gt; &lt;button @click="handleCamera()"&gt;打开相机&lt;/button&gt; &lt;button @click="showNavigator()"&gt;查看navigator.camera&lt;/button&gt; &lt;img id="myImage" src="" alt="获取相片"&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415onSuccess(imageData) &#123; var image = document.getElementById('myImage'); image.src = "data:image/jpeg;base64," + imageData;&#125;,onFail(message) &#123; alert('Failed because: ' + message);&#125;,handleCamera() &#123; navigator.camera.getPicture(this.onSuccess, this.onFail, &#123; quality: 25, destinationType: window.Camera.DestinationType.DATA_URL &#125;);&#125; 构建项目 vue 项目打包——生成 cordova 目录下的 www 文件 1npm run build cordova 项目打包 www 文件(注意切换目录) 1cordova build android 生成 apk 文件，我们安装到手机上——嗯!可以用的 貌似到这里就完了，可是。。。 每次都要发布 app 不累吗？而且用户也不喜欢啊！所以热更新来了 插件 Cordova Hot Code Push Plugin,基本原理是为 www 目录下的每个文件加多一个 hash 值追踪(chcp.manifest 文件)，有更改的文件便会被在 apk 启动检查到然后被更新 添加热更新插件,开发环境部署测试，热更新部署命令 123cordova plugin add cordova-hot-code-push-plugin --savecordova plugin add cordova-hot-code-push-local-dev-addon --savenpm install cordova-hot-code-push-cli --save 执行热更新发布并开启热更新环境 123cordova-hcp server// 或者只是执行热更新发布**这时候需要部署到线上环境**cordova-hcp build 这时候会生成cordovaDemo下的.chcpenv、www目录下的chcp.json、chcp.manifest文件 根据线上部署或生产调试设置热更新检查的–URL–(项目的地址，确保apk能访问得到配置文件)1234567&lt;chcp&gt; &lt;config-file url="URL/chcp.json" /&gt;&lt;/chcp&gt;&lt;plugin name="cordova-plugin-camera" spec="^4.0.3" /&gt;&lt;plugin name="cordova-hot-code-push-plugin" spec="^1.5.3" /&gt;&lt;plugin name="cordova-hot-code-push-local-dev-addon" spec="^0.4.2" /&gt;&lt;engine name="android" spec="7.0.0" /&gt; 最后cordova打包生成apk并安装（这里我指定URL为本机的局域网IP和对应的端口） 测试更新效果 修改Apache Cordova 为HotCodePush Cordova Vue项目重新打包 执行cordova-hcp server apk退出重新打开过几秒就可以看到，修改成功 一路走来好像顺风顺水的，其实并不是啊——调试！！！ 安卓真机调试我们可以用chrome://inspect/#devices或者android studio，当然后者更强大不过有时候对前端小伙伴来说 Chrome 的就够了，而且也亲切。 chrome://inspect/#devices 方式 直接在谷歌 url 复制粘贴该地址回车便可以进入该模式，开启Discover USB devices发现设备 打开手机的usb 调试模式，需要先打开开发者模式 连接手机打开网页，点击设备下出现的网页inspect进入调试 android studio 支持虚拟设备和真机调试 指定 android sdk 需要 android sdk 下的 ADB——用于连接调试设备 gradle 构建，apk 安装到手机，手机 apk 面的日志会打印到 logcat 中 tips inspect 时报错 http1.1 404 Not found——第一次使用 google inspect 需要翻墙下载一些东西 vue 项目 build 到 cordova 源项目；cordova 项目 build 到安卓项目，Android studio run 进行调试（或者直接 cordova 打包） cordova 项目的 index 中引入 Content-Security-Policy——不允许在 html 中直接添加事件，可以将它注释掉 部分 google 的 inspect 不兼容所有的手机网页所以测试是否连接成功首选手机 google 调试，怀疑和内核有关或者部分 app 内部做了限制]]></content>
      <tags>
        <tag>Hybrid APP 架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画]]></title>
    <url>%2F2018%2F05%2F04%2FCSS%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[区分 animation（动画）、transition（过渡）、 transform（变形）、translate(平移)；理解各个 css 属性对应的常用取值与应用 transform——对元素 2D 或 3D 转换1transform: none|transform-functions; transform-functions——对应函数有如下： translate：平移 scale：缩放 rotate(angle)：旋转 skew(angle)：倾斜 备注： 以上函数基于平面，其他对应的有-X、-Y、-3d，分别对应 X 轴、Y 轴、3D 转换 transform-functions 接受多个函数，eg：1transform: translate(10px,20px) scale(.5,.5); transition——定义过渡状态的过程1transition&#123; transition-property transition-duration transition-timing-function transition-delay&#125; 对应属性值概念如下： transition-delay transition-duration transition-property transition-timing-function——对应值 linear：匀速 ease-in：加速 ease-out：减速（ease-in-out） cubic-bezier 函数：自定义速度模式 触发方式： 伪类触发：:hover : focus :checked :active js 触发：toggleClass 注意： IE10+ 不是所有的CSS属性都支持transition transition的优点在于简单易用，但是它有几个很大的局限。 transition需要事件触发，所以没法在网页加载时自动发生。 transition是一次性的，不能重复发生，除非一再触发。 transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 Animation——定义帧动画(指定动画一个周期持续的时间，以及动画效果)1animation: 1s 1s actionName linear 3 forwards normal; 对应属性值 1234567animation-delay: 1s;animation-duration: 1s;animation-name: actionName;animation-timing-function: linear;animation-iteration-count: 3;animation-fill-mode: forwards;animation-direction: normal; 简写 1animation: 1s 1s rainbow linear 3 forwards normal; 动画事件对应处理 1234567891011@keyframes name &#123; from &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; to &#123; background: yellowgreen; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next建站踩坑记]]></title>
    <url>%2F2018%2F04%2F11%2Fhexo-next%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HEXO: A fast, simple &amp; powerful blog frameworkNEXT: A high quality elegant Hexo theme. It is crafted from scratch, with love hexo搭建网站丢上官网文档，按照官网的步骤走这里要了解一下各个目录文件的作用： public——最终生成的网站文件 scaffolds——生成文件模板，可定制个性化 source——顾名思义，我们对项目的内容编辑都在这里进行 博文——分为草稿、发布 静态资源存放地 其他页文件 thems——主题目录，对应得博客主题就存放在这里，当然也可以放多个随意切换 next主题引入与配置在引入next主题之前我是用yalia主题的，奈何发现各种小bug，虽然可以自定义修改，但是安装了npm包后，hexo编译主题文件不是一堆内存溢出就是打开文件太多错误提示。这个问题怀疑是hexo编译主题的时候把node_module一起……想想都可怕；移除了node_module之后就不会了，然后移进来又会了，oh shit！再去看着yalia一堆open的issue果断转投next。 还是丢官网文档，感觉官网文档很不错，不过坑还是有的，或者有一些雾里看花压根就没怎么和你讲。 侧边栏的各种关于、标签页都需要在配置新增之后显示，而后用hexo新增对应的页面，博客url管理是日期或者对应文件目录形式，可以看看public文件下面就知道了 查找功能 注意版本 本地查找一般没啥毛病——原理是基于本地搜索引擎全局查找web站点页面 algolia插件——远程备份需要查找匹配列表的关键信息（json形式），查找时去请求匹配到对应的数据，以便达到快速定位的查找项，以下是具体步骤： 创建注册algolia账号 安装hexo algolia用于生成推送文档关键词npm install --save hexo-algolia 配置站点配置文件algolia: applicationID: &apos;applicationID&apos; indexName: &apos;indexName&apos; chunkSize: 500 配置主题配置文件algolia: applicationID: apiKey: indexName: 推送更新搜索json至algoliahexo algolia 打开搜索功能配置项algolia_search: enable: true]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git备忘录]]></title>
    <url>%2F2018%2F04%2F10%2Fgit%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Git 理解与常用命令汇总 git 工作流作为一个版本控制管理系统工具，如何做到的？分布式管理仓库，分为当前工作区和.git 文件保存的文件版本管理区；一个版本统一 hash 值作为版本 ID；文件在工作区修改之后都需要提交更改到本地 git 的版本管理中才能推送更改到远程仓库中。具体的操作看图片 任何对象都是在工作区中诞生和被修改; 任何修改都是从进入 index 区才开始被版本控制; 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹; 与协作者分享本地的修改，可以把它们 push 到远程仓库来共享。 本地版本管理 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD 就会跟着改变，Git 允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id 版本标签: 1234567命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；命令git tag可以查看所有标签。 远程仓库同步 关联远程仓库：git remote add origin git@server-name:path/repo-name.git、git clone git@github.com:Devil0/repository.git 同步操作：push、pull、fetch 分支管理brach用于开发协同管理，涉及展示分支，切换分支，创建分支，删除分支这四种操作]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新认识JS]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[概述高中读化学时一直觉得知识点好零碎，徘徊门外分数也上不去；后来高一舍友告诉我要形成自己的体系，闭上眼睛都能想象得出化学的课本章节，可以从元素周期表或是有机无机开始为基点打造自己的学习体系脉络；说来也神奇，有了这个想法后学习真的轻松不少，打怪升级分数也上去了。废话有点多，谁让 js 是一门不需要学习就能直接先用的语言呢？导致不少人压根就迷迷糊糊的或者雾里看花似懂非懂；那个什么鬼前端知识图片就是坑，算了，入正题。。。 何为程序作为一个电子信息科学与技术专业，学硬件又学软件什么的，大学算是有过了一遍从基础电信号——数电——汇编——C 语言的大致历史，个人理解的电子世界是这样的：01 电信号构成基石——排列组合逻辑运算构成数字芯片实现一定功能（输入输出及存储），排列组合构成功能指令——为编程方便简化指令成为汇编语言（assembling）——进一步简化为各个分支c、c++、c#、java、.net……(高级语言) 定位——轻量级的脚本语言脚本语言的主要特征是：程序代码即是脚本程序，亦是最终可执行文件。脚本语言可分为独立型和嵌入型，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如 C，C++，VB，Java 等）被嵌入使用 JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 阮一峰什么是 JavaScript 语言 JS 在 web 方面应用，目前主要在宿主环境有 NODE 和浏览器，客户端与服务端。 js 的核心语法 类对象编程语法 基本的语法构造 标准库 宿主环境提供的 API 基础语法 基于规则的一门语言，类似我们学的自然语言，从最简单的拼音字母到词乃至句子表达的意思——对于程序来说则意味着命令 变量 标识符（保留字） 注释 区块 作用域 var const 与 let 逻辑语句 条件语句——if、switch、? : 循环语句——for、do until、while（break跳出当前循环、continue用于终止循环） 数据类型 js作为一门动态类型语言，其实是没有所谓类型可言，对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值 空类型 null undefined 原始类型/值类型——变量存值新开内存 string——base64（字符编码二进制转换用于传输）btoa()、atob() number——64位浮点数、精度、范围、parseInt（string,formats）、parseFloat boolean——自动转为false的情况：undefined、null、NaN、0、’’ 复合类型/引用类型——变量存对象地址新开内存，属性值另外存 object——子类有 array、function、object 对象深、浅拷贝null undefined区别值类型确定：typeof、instanceof、Object.prototype.toStringNaN（Not a Number）——任何运算都是自身，属于Number；Infinity——无穷大/小，非0数值除以0；两者运算求导，不可导为NaN typeof12typeof a === 'undefined' // 用于检测变量、函数是否定义!a &amp;&amp; typeof a === 'object' // 检测null，可检测出的为除null基本数据类型+function 对象概念： 数据集或功能集——面向对象编程123抽象性：抽取我们所需要的数据信息等封装性继承性 增删查改123456789// 增改obj.keyobj['key'] // 遍历key in objObject.keys(obj) // 自身属性for (let key in obj) // enumerable属性（结合hasOwnProperty修改自身key）// 删除delete obj.key // configurable为true的属性，否则为false 数组继承对象的特性，需要区分类数组（arguments）类数组转为数组或使用数组方法： 12let arr = Array.prototype.slice.call(arrayLike)Array.prototype.forEach.call(arrayLike, fn)]]></content>
      <categories>
        <category>JS体系</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
